import {
  shouldRenderHamburgerMenu
} from "./chunk-HKNGWITP.js";
import "./chunk-IPC4YNSI.js";
import "./chunk-3YG4HVQA.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_svg_attributes,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-4HN6M6VN.js";
import "./chunk-ZJ46KODL.js";
import "./chunk-2B2CG5KL.js";

// node_modules/carbon-components-svelte/src/icons/Close.svelte
var file = "node_modules/carbon-components-svelte/src/icons/Close.svelte";
function create_if_block(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data_dev(
          t,
          /*title*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
      add_location(path, file, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Close", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Close = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Close",
      options,
      id: create_fragment.name
    });
  }
  get size() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Close_default = Close;

// node_modules/carbon-components-svelte/src/icons/Menu.svelte
var file2 = "node_modules/carbon-components-svelte/src/icons/Menu.svelte";
function create_if_block2(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file2, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data_dev(
          t,
          /*title*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let svg;
  let path;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block2(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 6H28V8H4zM4 24H28V26H4zM4 12H28V14H4zM4 18H28V20H4z");
      add_location(path, file2, 24, 2, 579);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file2, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment2.name
    });
  }
  get size() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte
var file3 = "node_modules/carbon-components-svelte/src/UIShell/HamburgerMenu.svelte";
function create_fragment3(ctx) {
  let button;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*isOpen*/
    ctx[0] ? (
      /*iconClose*/
      ctx[4]
    ) : (
      /*iconMenu*/
      ctx[3]
    )
  );
  function switch_props(ctx2, dirty) {
    return { props: { size: 20 }, $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  let button_levels = [
    { type: "button" },
    { title: (
      /*ariaLabel*/
      ctx[2]
    ) },
    { "aria-label": (
      /*ariaLabel*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[5]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        title: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__menu-trigger", true);
      toggle_class(button, "bx--header__menu-toggle", true);
      add_location(button, file3, 31, 0, 768);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (switch_instance)
        mount_component(switch_instance, button, null);
      if (button.autofocus)
        button.focus();
      ctx[7](button);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler_1*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*isOpen, iconClose, iconMenu*/
      25 && switch_value !== (switch_value = /*isOpen*/
      ctx2[0] ? (
        /*iconClose*/
        ctx2[4]
      ) : (
        /*iconMenu*/
        ctx2[3]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, button, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*ariaLabel*/
        4) && { title: (
          /*ariaLabel*/
          ctx2[2]
        ) },
        (!current || dirty & /*ariaLabel*/
        4) && { "aria-label": (
          /*ariaLabel*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(button, "bx--header__action", true);
      toggle_class(button, "bx--header__menu-trigger", true);
      toggle_class(button, "bx--header__menu-toggle", true);
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["ariaLabel", "isOpen", "iconMenu", "iconClose", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HamburgerMenu", slots, []);
  let { ariaLabel = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { iconMenu = Menu_default } = $$props;
  let { iconClose = Close_default } = $$props;
  let { ref = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const click_handler_1 = () => $$invalidate(0, isOpen = !isOpen);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ariaLabel" in $$new_props)
      $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("iconMenu" in $$new_props)
      $$invalidate(3, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$new_props)
      $$invalidate(4, iconClose = $$new_props.iconClose);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    ariaLabel,
    isOpen,
    iconMenu,
    iconClose,
    ref,
    Close: Close_default,
    Menu: Menu_default
  });
  $$self.$inject_state = ($$new_props) => {
    if ("ariaLabel" in $$props)
      $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("iconMenu" in $$props)
      $$invalidate(3, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$props)
      $$invalidate(4, iconClose = $$new_props.iconClose);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    ref,
    ariaLabel,
    iconMenu,
    iconClose,
    $$restProps,
    click_handler,
    button_binding,
    click_handler_1
  ];
}
var HamburgerMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      ariaLabel: 2,
      isOpen: 0,
      iconMenu: 3,
      iconClose: 4,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HamburgerMenu",
      options,
      id: create_fragment3.name
    });
  }
  get ariaLabel() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconMenu() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconMenu(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClose() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClose(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HamburgerMenu_default = HamburgerMenu;

// node_modules/carbon-components-svelte/src/UIShell/Header.svelte
var file4 = "node_modules/carbon-components-svelte/src/UIShell/Header.svelte";
var get_platform_slot_changes = (dirty) => ({});
var get_platform_slot_context = (ctx) => ({});
var get_company_slot_changes = (dirty) => ({});
var get_company_slot_context = (ctx) => ({});
var get_skip_to_content_slot_changes = (dirty) => ({});
var get_skip_to_content_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let hamburgermenu;
  let updating_isOpen;
  let current;
  function hamburgermenu_isOpen_binding(value) {
    ctx[20](value);
  }
  let hamburgermenu_props = {
    iconClose: (
      /*iconClose*/
      ctx[8]
    ),
    iconMenu: (
      /*iconMenu*/
      ctx[7]
    )
  };
  if (
    /*isSideNavOpen*/
    ctx[0] !== void 0
  ) {
    hamburgermenu_props.isOpen = /*isSideNavOpen*/
    ctx[0];
  }
  hamburgermenu = new HamburgerMenu_default({
    props: hamburgermenu_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hamburgermenu, "isOpen", hamburgermenu_isOpen_binding));
  const block = {
    c: function create() {
      create_component(hamburgermenu.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hamburgermenu.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hamburgermenu, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hamburgermenu_changes = {};
      if (dirty & /*iconClose*/
      256)
        hamburgermenu_changes.iconClose = /*iconClose*/
        ctx2[8];
      if (dirty & /*iconMenu*/
      128)
        hamburgermenu_changes.iconMenu = /*iconMenu*/
        ctx2[7];
      if (!updating_isOpen && dirty & /*isSideNavOpen*/
      1) {
        updating_isOpen = true;
        hamburgermenu_changes.isOpen = /*isSideNavOpen*/
        ctx2[0];
        add_flush_callback(() => updating_isOpen = false);
      }
      hamburgermenu.$set(hamburgermenu_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hamburgermenu.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hamburgermenu.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hamburgermenu, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(84:2) {#if ($shouldRenderHamburgerMenu && winWidth < expansionBreakpoint) || persistentHamburgerMenu}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let span;
  let current;
  const company_slot_template = (
    /*#slots*/
    ctx[17].company
  );
  const company_slot = create_slot(
    company_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_company_slot_context
  );
  const company_slot_or_fallback = company_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (company_slot_or_fallback)
        company_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (company_slot_or_fallback)
        company_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(span, "bx--header__name--prefix", true);
      add_location(span, file4, 98, 6, 2665);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (company_slot_or_fallback) {
        company_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (company_slot) {
        if (company_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            company_slot,
            company_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              company_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_company_slot_changes
            ),
            get_company_slot_context
          );
        }
      } else {
        if (company_slot_or_fallback && company_slot_or_fallback.p && (!current || dirty & /*company*/
        8)) {
          company_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(company_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(company_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (company_slot_or_fallback)
        company_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(98:4) {#if company || $$slots.company}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(
        /*company*/
        ctx[3]
      );
      t1 = text(" ");
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*company*/
        ctx[3]
      );
      t1 = claim_text(nodes, " ");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*company*/
      8)
        set_data_dev(
          t0,
          /*company*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(100:30) {company}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*platformName*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*platformName*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*platformName*/
      16)
        set_data_dev(
          t,
          /*platformName*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(103:26) {platformName}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let header;
  let t0;
  let t1;
  let a;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[19]
  );
  const skip_to_content_slot_template = (
    /*#slots*/
    ctx[17]["skip-to-content"]
  );
  const skip_to_content_slot = create_slot(
    skip_to_content_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_skip_to_content_slot_context
  );
  let if_block0 = (
    /*$shouldRenderHamburgerMenu*/
    (ctx[11] && /*winWidth*/
    ctx[9] < /*expansionBreakpoint*/
    ctx[6] || /*persistentHamburgerMenu*/
    ctx[5]) && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*company*/
    (ctx[3] || /*$$slots*/
    ctx[13].company) && create_if_block3(ctx)
  );
  const platform_slot_template = (
    /*#slots*/
    ctx[17].platform
  );
  const platform_slot = create_slot(
    platform_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_platform_slot_context
  );
  const platform_slot_or_fallback = platform_slot || fallback_block(ctx);
  let a_levels = [
    { href: (
      /*href*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[12]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      header = element("header");
      if (skip_to_content_slot)
        skip_to_content_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      a = element("a");
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (platform_slot_or_fallback)
        platform_slot_or_fallback.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { "aria-label": true });
      var header_nodes = children(header);
      if (skip_to_content_slot)
        skip_to_content_slot.l(header_nodes);
      t0 = claim_space(header_nodes);
      if (if_block0)
        if_block0.l(header_nodes);
      t1 = claim_space(header_nodes);
      a = claim_element(header_nodes, "A", { href: true });
      var a_nodes = children(a);
      if (if_block1)
        if_block1.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (platform_slot_or_fallback)
        platform_slot_or_fallback.l(a_nodes);
      a_nodes.forEach(detach_dev);
      t3 = claim_space(header_nodes);
      if (default_slot)
        default_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(a, "bx--header__name", true);
      add_location(a, file4, 90, 2, 2505);
      attr_dev(
        header,
        "aria-label",
        /*ariaLabel*/
        ctx[10]
      );
      toggle_class(header, "bx--header", true);
      add_location(header, file4, 81, 0, 2183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (skip_to_content_slot) {
        skip_to_content_slot.m(header, null);
      }
      append_hydration_dev(header, t0);
      if (if_block0)
        if_block0.m(header, null);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, a);
      if (if_block1)
        if_block1.m(a, null);
      append_hydration_dev(a, t2);
      if (platform_slot_or_fallback) {
        platform_slot_or_fallback.m(a, null);
      }
      ctx[21](a);
      append_hydration_dev(header, t3);
      if (default_slot) {
        default_slot.m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "resize",
            /*onwindowresize*/
            ctx[19]
          ),
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (skip_to_content_slot) {
        if (skip_to_content_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            skip_to_content_slot,
            skip_to_content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              skip_to_content_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_skip_to_content_slot_changes
            ),
            get_skip_to_content_slot_context
          );
        }
      }
      if (
        /*$shouldRenderHamburgerMenu*/
        ctx2[11] && /*winWidth*/
        ctx2[9] < /*expansionBreakpoint*/
        ctx2[6] || /*persistentHamburgerMenu*/
        ctx2[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$shouldRenderHamburgerMenu, winWidth, expansionBreakpoint, persistentHamburgerMenu*/
          2656) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(header, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*company*/
        ctx2[3] || /*$$slots*/
        ctx2[13].company
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*company, $$slots*/
          8200) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(a, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (platform_slot) {
        if (platform_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            platform_slot,
            platform_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              platform_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_platform_slot_changes
            ),
            get_platform_slot_context
          );
        }
      } else {
        if (platform_slot_or_fallback && platform_slot_or_fallback.p && (!current || dirty & /*platformName*/
        16)) {
          platform_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        4) && { href: (
          /*href*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      toggle_class(a, "bx--header__name", true);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*ariaLabel*/
      1024) {
        attr_dev(
          header,
          "aria-label",
          /*ariaLabel*/
          ctx2[10]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(skip_to_content_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(platform_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(skip_to_content_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(platform_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      if (skip_to_content_slot)
        skip_to_content_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (platform_slot_or_fallback)
        platform_slot_or_fallback.d(detaching);
      ctx[21](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let ariaLabel;
  const omit_props_names = [
    "expandedByDefault",
    "isSideNavOpen",
    "uiShellAriaLabel",
    "href",
    "company",
    "platformName",
    "persistentHamburgerMenu",
    "expansionBreakpoint",
    "ref",
    "iconMenu",
    "iconClose"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $shouldRenderHamburgerMenu;
  validate_store(shouldRenderHamburgerMenu, "shouldRenderHamburgerMenu");
  component_subscribe($$self, shouldRenderHamburgerMenu, ($$value) => $$invalidate(11, $shouldRenderHamburgerMenu = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["skip-to-content", "company", "platform", "default"]);
  const $$slots = compute_slots(slots);
  let { expandedByDefault = true } = $$props;
  let { isSideNavOpen = false } = $$props;
  let { uiShellAriaLabel = void 0 } = $$props;
  let { href = void 0 } = $$props;
  let { company = void 0 } = $$props;
  let { platformName = "" } = $$props;
  let { persistentHamburgerMenu = false } = $$props;
  let { expansionBreakpoint = 1056 } = $$props;
  let { ref = null } = $$props;
  let { iconMenu = Menu_default } = $$props;
  let { iconClose = Close_default } = $$props;
  let winWidth = void 0;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function onwindowresize() {
    $$invalidate(9, winWidth = window.innerWidth);
  }
  function hamburgermenu_isOpen_binding(value) {
    isSideNavOpen = value;
    $$invalidate(0, isSideNavOpen), $$invalidate(14, expandedByDefault), $$invalidate(9, winWidth), $$invalidate(6, expansionBreakpoint), $$invalidate(5, persistentHamburgerMenu);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("expandedByDefault" in $$new_props)
      $$invalidate(14, expandedByDefault = $$new_props.expandedByDefault);
    if ("isSideNavOpen" in $$new_props)
      $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    if ("uiShellAriaLabel" in $$new_props)
      $$invalidate(15, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("company" in $$new_props)
      $$invalidate(3, company = $$new_props.company);
    if ("platformName" in $$new_props)
      $$invalidate(4, platformName = $$new_props.platformName);
    if ("persistentHamburgerMenu" in $$new_props)
      $$invalidate(5, persistentHamburgerMenu = $$new_props.persistentHamburgerMenu);
    if ("expansionBreakpoint" in $$new_props)
      $$invalidate(6, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("iconMenu" in $$new_props)
      $$invalidate(7, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$new_props)
      $$invalidate(8, iconClose = $$new_props.iconClose);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    expandedByDefault,
    isSideNavOpen,
    uiShellAriaLabel,
    href,
    company,
    platformName,
    persistentHamburgerMenu,
    expansionBreakpoint,
    ref,
    iconMenu,
    iconClose,
    Close: Close_default,
    Menu: Menu_default,
    shouldRenderHamburgerMenu,
    HamburgerMenu: HamburgerMenu_default,
    winWidth,
    ariaLabel,
    $shouldRenderHamburgerMenu
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("expandedByDefault" in $$props)
      $$invalidate(14, expandedByDefault = $$new_props.expandedByDefault);
    if ("isSideNavOpen" in $$props)
      $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    if ("uiShellAriaLabel" in $$props)
      $$invalidate(15, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("company" in $$props)
      $$invalidate(3, company = $$new_props.company);
    if ("platformName" in $$props)
      $$invalidate(4, platformName = $$new_props.platformName);
    if ("persistentHamburgerMenu" in $$props)
      $$invalidate(5, persistentHamburgerMenu = $$new_props.persistentHamburgerMenu);
    if ("expansionBreakpoint" in $$props)
      $$invalidate(6, expansionBreakpoint = $$new_props.expansionBreakpoint);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("iconMenu" in $$props)
      $$invalidate(7, iconMenu = $$new_props.iconMenu);
    if ("iconClose" in $$props)
      $$invalidate(8, iconClose = $$new_props.iconClose);
    if ("winWidth" in $$props)
      $$invalidate(9, winWidth = $$new_props.winWidth);
    if ("ariaLabel" in $$props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*expandedByDefault, winWidth, expansionBreakpoint, persistentHamburgerMenu*/
    16992) {
      $:
        $$invalidate(0, isSideNavOpen = expandedByDefault && winWidth >= expansionBreakpoint && !persistentHamburgerMenu);
    }
    $:
      $$invalidate(10, ariaLabel = company ? `${company} ` : "" + (uiShellAriaLabel || $$props["aria-label"] || platformName));
  };
  $$props = exclude_internal_props($$props);
  return [
    isSideNavOpen,
    ref,
    href,
    company,
    platformName,
    persistentHamburgerMenu,
    expansionBreakpoint,
    iconMenu,
    iconClose,
    winWidth,
    ariaLabel,
    $shouldRenderHamburgerMenu,
    $$restProps,
    $$slots,
    expandedByDefault,
    uiShellAriaLabel,
    $$scope,
    slots,
    click_handler,
    onwindowresize,
    hamburgermenu_isOpen_binding,
    a_binding
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      expandedByDefault: 14,
      isSideNavOpen: 0,
      uiShellAriaLabel: 15,
      href: 2,
      company: 3,
      platformName: 4,
      persistentHamburgerMenu: 5,
      expansionBreakpoint: 6,
      ref: 1,
      iconMenu: 7,
      iconClose: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment4.name
    });
  }
  get expandedByDefault() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedByDefault(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSideNavOpen() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSideNavOpen(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get uiShellAriaLabel() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set uiShellAriaLabel(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get company() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set company(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get platformName() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set platformName(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistentHamburgerMenu() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistentHamburgerMenu(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expansionBreakpoint() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expansionBreakpoint(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconMenu() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconMenu(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconClose() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconClose(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;
export {
  Header_default as default
};
//# sourceMappingURL=carbon-components-svelte_src_UIShell_Header__svelte.js.map
