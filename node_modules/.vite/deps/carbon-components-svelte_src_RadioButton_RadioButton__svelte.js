import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-IPC4YNSI.js";
import "./chunk-3YG4HVQA.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  prop_dev,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-4HN6M6VN.js";
import "./chunk-ZJ46KODL.js";
import "./chunk-2B2CG5KL.js";

// node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte
var file = "node_modules/carbon-components-svelte/src/RadioButton/RadioButton.svelte";
var get_labelText_slot_changes = (dirty) => ({});
var get_labelText_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let span;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[16].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_labelText_slot_context
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(
        span,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[7]
      );
      add_location(span, file, 74, 6, 1826);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_labelText_slot_changes
            ),
            get_labelText_slot_context
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        64)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*hideLabel*/
      128) {
        toggle_class(
          span,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[7]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(74:4) {#if labelText || $$slots.labelText}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      64)
        set_data_dev(
          t,
          /*labelText*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(76:31)            ",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let span;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*labelText*/
    (ctx[6] || /*$$slots*/
    ctx[13].labelText) && create_if_block(ctx)
  );
  let div_levels = [
    /*$$restProps*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      span = element("span");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, id: true, name: true });
      t0 = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      span = claim_element(label_nodes, "SPAN", {});
      children(span).forEach(detach_dev);
      t1 = claim_space(label_nodes);
      if (if_block)
        if_block.l(label_nodes);
      label_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[8]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[9]
      );
      input.checked = /*checked*/
      ctx[0];
      input.disabled = /*disabled*/
      ctx[3];
      input.required = /*required*/
      ctx[4];
      input.value = /*value*/
      ctx[2];
      toggle_class(input, "bx--radio-button", true);
      add_location(input, file, 54, 2, 1344);
      toggle_class(span, "bx--radio-button__appearance", true);
      add_location(span, file, 72, 4, 1721);
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[8]
      );
      toggle_class(label, "bx--radio-button__label", true);
      add_location(label, file, 71, 2, 1659);
      set_attributes(div, div_data);
      toggle_class(div, "bx--radio-button-wrapper", true);
      toggle_class(
        div,
        "bx--radio-button-wrapper--label-left",
        /*labelPosition*/
        ctx[5] === "left"
      );
      add_location(div, file, 49, 0, 1200);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx[18](input);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, label);
      append_hydration_dev(label, span);
      append_hydration_dev(label, t1);
      if (if_block)
        if_block.m(label, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*id*/
      256) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*name*/
      512) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*checked*/
      1) {
        prop_dev(
          input,
          "checked",
          /*checked*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*required*/
      16) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*value*/
      4) {
        prop_dev(
          input,
          "value",
          /*value*/
          ctx2[2]
        );
      }
      if (
        /*labelText*/
        ctx2[6] || /*$$slots*/
        ctx2[13].labelText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*labelText, $$slots*/
          8256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*id*/
      256) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[8]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4096 && /*$$restProps*/
      ctx2[12]]));
      toggle_class(div, "bx--radio-button-wrapper", true);
      toggle_class(
        div,
        "bx--radio-button-wrapper--label-left",
        /*labelPosition*/
        ctx2[5] === "left"
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[18](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "value",
    "checked",
    "disabled",
    "required",
    "labelPosition",
    "labelText",
    "hideLabel",
    "id",
    "name",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButton", slots, ["labelText"]);
  const $$slots = compute_slots(slots);
  let { value = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { labelPosition = "right" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = "" } = $$props;
  let { ref = null } = $$props;
  const ctx = getContext("RadioButtonGroup");
  const selectedValue = ctx ? ctx.selectedValue : writable(checked ? value : void 0);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(14, $selectedValue = value2));
  if (ctx) {
    ctx.add({ id, checked, disabled, value });
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  const change_handler_1 = () => {
    if (ctx) {
      ctx.update(value);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(4, required = $$new_props.required);
    if ("labelPosition" in $$new_props)
      $$invalidate(5, labelPosition = $$new_props.labelPosition);
    if ("labelText" in $$new_props)
      $$invalidate(6, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(7, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props)
      $$invalidate(8, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$new_props)
      $$invalidate(1, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    value,
    checked,
    disabled,
    required,
    labelPosition,
    labelText,
    hideLabel,
    id,
    name,
    ref,
    getContext,
    writable,
    ctx,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(4, required = $$new_props.required);
    if ("labelPosition" in $$props)
      $$invalidate(5, labelPosition = $$new_props.labelPosition);
    if ("labelText" in $$props)
      $$invalidate(6, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(7, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props)
      $$invalidate(8, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(9, name = $$new_props.name);
    if ("ref" in $$props)
      $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedValue, value*/
    16388) {
      $:
        $$invalidate(0, checked = $selectedValue === value);
    }
  };
  return [
    checked,
    ref,
    value,
    disabled,
    required,
    labelPosition,
    labelText,
    hideLabel,
    id,
    name,
    ctx,
    selectedValue,
    $$restProps,
    $$slots,
    $selectedValue,
    $$scope,
    slots,
    change_handler,
    input_binding,
    change_handler_1
  ];
}
var RadioButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      value: 2,
      checked: 0,
      disabled: 3,
      required: 4,
      labelPosition: 5,
      labelText: 6,
      hideLabel: 7,
      id: 8,
      name: 9,
      ref: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButton",
      options,
      id: create_fragment.name
    });
  }
  get value() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<RadioButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<RadioButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButton_default = RadioButton;
export {
  RadioButton_default as default
};
//# sourceMappingURL=carbon-components-svelte_src_RadioButton_RadioButton__svelte.js.map
