import "./chunk-6CJGRA3E.js";
import {
  writable
} from "./chunk-ANCNHGHB.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  beforeUpdate,
  bubble,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_store_value,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-54ILQR5V.js";
import "./chunk-NFXY5EW3.js";
import "./chunk-T2T6Q22Z.js";

// node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte
var file = "node_modules/carbon-components-svelte/src/RadioButtonGroup/RadioButtonGroup.svelte";
var get_legendText_slot_changes = (dirty) => ({});
var get_legendText_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let legend;
  let current;
  const legendText_slot_template = (
    /*#slots*/
    ctx[11].legendText
  );
  const legendText_slot = create_slot(
    legendText_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_legendText_slot_context
  );
  const legendText_slot_or_fallback = legendText_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      legend = element("legend");
      if (legendText_slot_or_fallback)
        legendText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      legend = claim_element(nodes, "LEGEND", {});
      var legend_nodes = children(legend);
      if (legendText_slot_or_fallback)
        legendText_slot_or_fallback.l(legend_nodes);
      legend_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(legend, "bx--label", true);
      toggle_class(
        legend,
        "bx--visually-hidden",
        /*hideLegend*/
        ctx[2]
      );
      add_location(legend, file, 90, 6, 1999);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend, anchor);
      if (legendText_slot_or_fallback) {
        legendText_slot_or_fallback.m(legend, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (legendText_slot) {
        if (legendText_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            legendText_slot,
            legendText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              legendText_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_legendText_slot_changes
            ),
            get_legendText_slot_context
          );
        }
      } else {
        if (legendText_slot_or_fallback && legendText_slot_or_fallback.p && (!current || dirty & /*legendText*/
        2)) {
          legendText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*hideLegend*/
      4) {
        toggle_class(
          legend,
          "bx--visually-hidden",
          /*hideLegend*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(legendText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(legendText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(legend);
      }
      if (legendText_slot_or_fallback)
        legendText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(90:4) {#if legendText || $$slots.legendText}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*legendText*/
        ctx[1]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*legendText*/
        ctx[1]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*legendText*/
      2)
        set_data_dev(
          t,
          /*legendText*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(92:32) {legendText}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let fieldset;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*legendText*/
    (ctx[1] || /*$$slots*/
    ctx[8].legendText) && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div_levels = [
    { id: (
      /*id*/
      ctx[5]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      fieldset = element("fieldset");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      fieldset = claim_element(div_nodes, "FIELDSET", {});
      var fieldset_nodes = children(fieldset);
      if (if_block)
        if_block.l(fieldset_nodes);
      t = claim_space(fieldset_nodes);
      if (default_slot)
        default_slot.l(fieldset_nodes);
      fieldset_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      fieldset.disabled = /*disabled*/
      ctx[0];
      toggle_class(fieldset, "bx--radio-button-group", true);
      toggle_class(
        fieldset,
        "bx--radio-button-group--vertical",
        /*orientation*/
        ctx[4] === "vertical"
      );
      toggle_class(
        fieldset,
        "bx--radio-button-group--label-left",
        /*labelPosition*/
        ctx[3] === "left"
      );
      toggle_class(
        fieldset,
        "bx--radio-button-group--label-right",
        /*labelPosition*/
        ctx[3] === "right"
      );
      add_location(fieldset, file, 82, 2, 1644);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      add_location(div, file, 73, 0, 1515);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, fieldset);
      if (if_block)
        if_block.m(fieldset, null);
      append_hydration_dev(fieldset, t);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*legendText*/
        ctx2[1] || /*$$slots*/
        ctx2[8].legendText
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*legendText, $$slots*/
          258) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*disabled*/
      1) {
        prop_dev(
          fieldset,
          "disabled",
          /*disabled*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*orientation*/
      16) {
        toggle_class(
          fieldset,
          "bx--radio-button-group--vertical",
          /*orientation*/
          ctx2[4] === "vertical"
        );
      }
      if (!current || dirty & /*labelPosition*/
      8) {
        toggle_class(
          fieldset,
          "bx--radio-button-group--label-left",
          /*labelPosition*/
          ctx2[3] === "left"
        );
      }
      if (!current || dirty & /*labelPosition*/
      8) {
        toggle_class(
          fieldset,
          "bx--radio-button-group--label-right",
          /*labelPosition*/
          ctx2[3] === "right"
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*id*/
        32) && { id: (
          /*id*/
          ctx2[5]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
      toggle_class(div, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "selected",
    "disabled",
    "legendText",
    "hideLegend",
    "labelPosition",
    "orientation",
    "id"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtonGroup", slots, ["legendText", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { legendText = "" } = $$props;
  let { hideLegend = false } = $$props;
  let { labelPosition = "right" } = $$props;
  let { orientation = "horizontal" } = $$props;
  let { id = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(16, $selectedValue = value));
  setContext("RadioButtonGroup", {
    selectedValue,
    add: ({ checked, value }) => {
      if (checked) {
        selectedValue.set(value);
      }
    },
    update: (value) => {
      $$invalidate(9, selected = value);
    }
  });
  onMount(() => {
    set_store_value(selectedValue, $selectedValue = selected, $selectedValue);
  });
  beforeUpdate(() => {
    set_store_value(selectedValue, $selectedValue = selected, $selectedValue);
  });
  selectedValue.subscribe((value) => {
    $$invalidate(9, selected = value);
    dispatch("change", value);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(9, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("legendText" in $$new_props)
      $$invalidate(1, legendText = $$new_props.legendText);
    if ("hideLegend" in $$new_props)
      $$invalidate(2, hideLegend = $$new_props.hideLegend);
    if ("labelPosition" in $$new_props)
      $$invalidate(3, labelPosition = $$new_props.labelPosition);
    if ("orientation" in $$new_props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    disabled,
    legendText,
    hideLegend,
    labelPosition,
    orientation,
    id,
    beforeUpdate,
    createEventDispatcher,
    onMount,
    setContext,
    writable,
    dispatch,
    selectedValue,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(9, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("legendText" in $$props)
      $$invalidate(1, legendText = $$new_props.legendText);
    if ("hideLegend" in $$props)
      $$invalidate(2, hideLegend = $$new_props.hideLegend);
    if ("labelPosition" in $$props)
      $$invalidate(3, labelPosition = $$new_props.labelPosition);
    if ("orientation" in $$props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    disabled,
    legendText,
    hideLegend,
    labelPosition,
    orientation,
    id,
    selectedValue,
    $$restProps,
    $$slots,
    selected,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var RadioButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      selected: 9,
      disabled: 0,
      legendText: 1,
      hideLegend: 2,
      labelPosition: 3,
      orientation: 4,
      id: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtonGroup",
      options,
      id: create_fragment.name
    });
  }
  get selected() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legendText() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legendText(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLegend() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLegend(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RadioButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioButtonGroup_default = RadioButtonGroup;
export {
  RadioButtonGroup_default as default
};
//# sourceMappingURL=carbon-components-svelte_src_RadioButtonGroup_RadioButtonGroup__svelte.js.map
