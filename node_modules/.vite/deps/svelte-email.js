import {
  convert
} from "./chunk-EFWYSEH7.js";
import {
  require_pretty
} from "./chunk-HJB6CQAF.js";
import "./chunk-3YG4HVQA.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  children,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_data_maybe_contenteditable_dev,
  set_dynamic_element_data,
  space,
  src_url_equal,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-JVJWPZ6M.js";
import "./chunk-ZJ46KODL.js";
import {
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/svelte-email/utils.js
var pxToPt = (px) => isNaN(Number(px)) ? null : parseInt(px, 10) * 3 / 4;
var withMargin = (props) => [
  withSpace(props.m, ["margin"]),
  withSpace(props.mx, ["marginLeft", "marginRight"]),
  withSpace(props.my, ["marginTop", "marginBottom"]),
  withSpace(props.mt, ["marginTop"]),
  withSpace(props.mr, ["marginRight"]),
  withSpace(props.mb, ["marginBottom"]),
  withSpace(props.ml, ["marginLeft"])
].filter((s) => Object.keys(s).length)[0];
var withSpace = (value, properties) => {
  return properties.reduce((styles, property) => {
    if (value) {
      return { ...styles, [property]: `${value}px` };
    }
    return styles;
  }, {});
};
var styleToString = (style) => {
  return Object.keys(style).reduce((acc, key) => acc + key.split(/(?=[A-Z])/).join("-").toLowerCase() + ":" + style[key] + ";", "");
};

// node_modules/svelte-email/components/Body.svelte
var file = "node_modules/svelte-email/components/Body.svelte";
function create_fragment(ctx) {
  let body;
  let body_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let body_levels = [
    /*$$restProps*/
    ctx[1],
    {
      style: body_style_value = styleToString(
        /*style*/
        ctx[0]
      )
    }
  ];
  let body_data = {};
  for (let i = 0; i < body_levels.length; i += 1) {
    body_data = assign(body_data, body_levels[i]);
  }
  const block = {
    c: function create() {
      body = element("body");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      body = claim_element(nodes, "BODY", { style: true });
      var body_nodes = children(body);
      if (default_slot)
        default_slot.l(body_nodes);
      body_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(body, body_data);
      add_location(body, file, 4, 0, 84);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, body, anchor);
      if (default_slot) {
        default_slot.m(body, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(body, body_data = get_spread_update(body_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        (!current || dirty & /*style*/
        1 && body_style_value !== (body_style_value = styleToString(
          /*style*/
          ctx2[0]
        ))) && { style: body_style_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(body);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Body", slots, ["default"]);
  let { style = {} } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ styleToString, style });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [style, $$restProps, $$scope, slots];
}
var Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { style: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Body",
      options,
      id: create_fragment.name
    });
  }
  get style() {
    throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Body_default = Body;

// node_modules/svelte-email/components/Button.svelte
var file2 = "node_modules/svelte-email/components/Button.svelte";
function create_fragment2(ctx) {
  let a;
  let span0;
  let html_tag;
  let raw0_value = `<!--[if mso]><i style="letter-spacing: ${/*pX*/
  ctx[2]}px;mso-font-width:-100%;mso-text-raise:${/*textRaise*/
  ctx[5]}" hidden>&nbsp;</i><![endif]-->`;
  let t0;
  let span1;
  let span1_style_value;
  let t1;
  let span2;
  let html_tag_1;
  let raw1_value = `<!--[if mso]><i style="letter-spacing: ${/*pX*/
  ctx[2]}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`;
  let a_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[8],
    { href: (
      /*href*/
      ctx[0]
    ) },
    { target: (
      /*target*/
      ctx[4]
    ) },
    {
      style: a_style_value = styleToString(
        /*buttonStyle*/
        ctx[6]({
          .../*style*/
          ctx[1],
          pX: (
            /*pX*/
            ctx[2]
          ),
          pY: (
            /*pY*/
            ctx[3]
          )
        })
      )
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      span0 = element("span");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      span1 = element("span");
      if (default_slot)
        default_slot.c();
      t1 = space();
      span2 = element("span");
      html_tag_1 = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, target: true, style: true });
      var a_nodes = children(a);
      span0 = claim_element(a_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      html_tag = claim_html_tag(span0_nodes, false);
      span0_nodes.forEach(detach_dev);
      t0 = claim_space(a_nodes);
      span1 = claim_element(a_nodes, "SPAN", { style: true });
      var span1_nodes = children(span1);
      if (default_slot)
        default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      t1 = claim_space(a_nodes);
      span2 = claim_element(a_nodes, "SPAN", {});
      var span2_nodes = children(span2);
      html_tag_1 = claim_html_tag(span2_nodes, false);
      span2_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      add_location(span0, file2, 36, 1, 931);
      attr_dev(span1, "style", span1_style_value = styleToString(
        /*buttonTextStyle*/
        ctx[7]({
          .../*style*/
          ctx[1],
          pX: (
            /*pX*/
            ctx[2]
          ),
          pY: (
            /*pY*/
            ctx[3]
          )
        })
      ));
      add_location(span1, file2, 39, 1, 1087);
      html_tag_1.a = null;
      add_location(span2, file2, 42, 1, 1176);
      set_attributes(a, a_data);
      add_location(a, file2, 35, 0, 836);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, span0);
      html_tag.m(raw0_value, span0);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      append_hydration_dev(a, t1);
      append_hydration_dev(a, span2);
      html_tag_1.m(raw1_value, span2);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if ((!current || dirty & /*pX*/
      4) && raw0_value !== (raw0_value = `<!--[if mso]><i style="letter-spacing: ${/*pX*/
      ctx2[2]}px;mso-font-width:-100%;mso-text-raise:${/*textRaise*/
      ctx2[5]}" hidden>&nbsp;</i><![endif]-->`))
        html_tag.p(raw0_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*style, pX, pY*/
      14 && span1_style_value !== (span1_style_value = styleToString(
        /*buttonTextStyle*/
        ctx2[7]({
          .../*style*/
          ctx2[1],
          pX: (
            /*pX*/
            ctx2[2]
          ),
          pY: (
            /*pY*/
            ctx2[3]
          )
        })
      ))) {
        attr_dev(span1, "style", span1_style_value);
      }
      if ((!current || dirty & /*pX*/
      4) && raw1_value !== (raw1_value = `<!--[if mso]><i style="letter-spacing: ${/*pX*/
      ctx2[2]}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`))
        html_tag_1.p(raw1_value);
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8],
        (!current || dirty & /*href*/
        1) && { href: (
          /*href*/
          ctx2[0]
        ) },
        (!current || dirty & /*target*/
        16) && { target: (
          /*target*/
          ctx2[4]
        ) },
        (!current || dirty & /*style, pX, pY*/
        14 && a_style_value !== (a_style_value = styleToString(
          /*buttonStyle*/
          ctx2[6]({
            .../*style*/
            ctx2[1],
            pX: (
              /*pX*/
              ctx2[2]
            ),
            pY: (
              /*pY*/
              ctx2[3]
            )
          })
        ))) && { style: a_style_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["href", "style", "pX", "pY", "target"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { href = "" } = $$props;
  let { style = {} } = $$props;
  let { pX = 0 } = $$props;
  let { pY = 0 } = $$props;
  let { target = "_blank" } = $$props;
  const y = pY * 2;
  const textRaise = pxToPt(y.toString());
  const buttonStyle = (style2) => {
    const paddingY = (style2 == null ? void 0 : style2.pY) || 0;
    const paddingX = (style2 == null ? void 0 : style2.pX) || 0;
    return {
      ...style2,
      lineHeight: "100%",
      textDecoration: "none",
      display: "inline-block",
      maxWidth: "100%",
      padding: `${paddingY}px ${paddingX}px`
    };
  };
  const buttonTextStyle = (style2) => {
    const paddingY = (style2 == null ? void 0 : style2.pY) || 0;
    return {
      ...style2,
      maxWidth: "100%",
      display: "inline-block",
      lineHeight: "120%",
      textDecoration: "none",
      textTransform: "none",
      msoPaddingAlt: "0px",
      msoTextRaise: pxToPt(paddingY.toString())
    };
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("style" in $$new_props)
      $$invalidate(1, style = $$new_props.style);
    if ("pX" in $$new_props)
      $$invalidate(2, pX = $$new_props.pX);
    if ("pY" in $$new_props)
      $$invalidate(3, pY = $$new_props.pY);
    if ("target" in $$new_props)
      $$invalidate(4, target = $$new_props.target);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    pxToPt,
    styleToString,
    href,
    style,
    pX,
    pY,
    target,
    y,
    textRaise,
    buttonStyle,
    buttonTextStyle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("style" in $$props)
      $$invalidate(1, style = $$new_props.style);
    if ("pX" in $$props)
      $$invalidate(2, pX = $$new_props.pX);
    if ("pY" in $$props)
      $$invalidate(3, pY = $$new_props.pY);
    if ("target" in $$props)
      $$invalidate(4, target = $$new_props.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    href,
    style,
    pX,
    pY,
    target,
    textRaise,
    buttonStyle,
    buttonTextStyle,
    $$restProps,
    $$scope,
    slots
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      href: 0,
      style: 1,
      pX: 2,
      pY: 3,
      target: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment2.name
    });
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pX() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pX(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pY() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pY(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/svelte-email/components/Column.svelte
var file3 = "node_modules/svelte-email/components/Column.svelte";
function create_fragment3(ctx) {
  let td;
  let td_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let td_levels = [
    {
      style: td_style_value = styleToString(
        /*styleDefault*/
        ctx[0]
      )
    },
    { role: "presentation" },
    /*$$restProps*/
    ctx[1]
  ];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { style: true, role: true });
      var td_nodes = children(td);
      if (default_slot)
        default_slot.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(td, td_data);
      add_location(td, file3, 10, 0, 199);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        { style: td_style_value },
        { role: "presentation" },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["default"]);
  let { style = {} } = $$props;
  const styleDefault = {
    display: "inline-flex",
    justifyContent: "center",
    alignItems: "center",
    ...style
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ styleToString, style, styleDefault });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [styleDefault, $$restProps, style, $$scope, slots];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { style: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment3.name
    });
  }
  get style() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/svelte-email/components/Container.svelte
var file4 = "node_modules/svelte-email/components/Container.svelte";
function create_fragment4(ctx) {
  let div0;
  let html_tag;
  let raw0_value = `<!--[if mso | IE]>
          <table role="presentation" width="100%" align="center" style="${/*inlineStyle*/
  ctx[0]}"><tr><td></td><td style="width:37.5em;background:#ffffff">
        <![endif]-->`;
  let t0;
  let div1;
  let t1;
  let div2;
  let html_tag_1;
  let raw1_value = `<!--[if mso | IE]>
          </td><td></td></tr></table>
          <![endif]-->`;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div1_levels = [
    /*$$restProps*/
    ctx[1],
    { style: (
      /*inlineStyle*/
      ctx[0]
    ) }
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div0 = element("div");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div2 = element("div");
      html_tag_1 = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      html_tag = claim_html_tag(div0_nodes, false);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      html_tag_1 = claim_html_tag(div2_nodes, false);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      add_location(div0, file4, 6, 0, 176);
      set_attributes(div1, div_data_1);
      add_location(div1, file4, 11, 0, 386);
      html_tag_1.a = null;
      add_location(div2, file4, 14, 0, 446);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      html_tag.m(raw0_value, div0);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div2, anchor);
      html_tag_1.m(raw1_value, div2);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { style: (
          /*inlineStyle*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t0);
        detach_dev(div1);
        detach_dev(t1);
        detach_dev(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  let { style = {} } = $$props;
  const styles = { maxWidth: "37.5em", ...style };
  const inlineStyle = styleToString(styles);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    styleToString,
    style,
    styles,
    inlineStyle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [inlineStyle, $$restProps, style, $$scope, slots];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { style: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment4.name
    });
  }
  get style() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/svelte-email/components/Head.svelte
var file5 = "node_modules/svelte-email/components/Head.svelte";
function create_fragment5(ctx) {
  let head;
  let meta;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let head_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let head_data = {};
  for (let i = 0; i < head_levels.length; i += 1) {
    head_data = assign(head_data, head_levels[i]);
  }
  const block = {
    c: function create() {
      head = element("head");
      meta = element("meta");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      head = claim_element(nodes, "HEAD", {});
      var head_nodes = children(head);
      meta = claim_element(head_nodes, "META", { httpequiv: true, content: true });
      t = claim_space(head_nodes);
      if (default_slot)
        default_slot.l(head_nodes);
      head_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "httpequiv", "Content-Type");
      attr_dev(meta, "content", "text/html; charset=UTF-8");
      add_location(meta, file5, 3, 1, 44);
      set_attributes(head, head_data);
      add_location(head, file5, 2, 0, 19);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, head, anchor);
      append_hydration_dev(head, meta);
      append_hydration_dev(head, t);
      if (default_slot) {
        default_slot.m(head, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(head, head_data = get_spread_update(head_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(head);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Head", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$scope, slots];
}
var Head = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Head",
      options,
      id: create_fragment5.name
    });
  }
};
var Head_default = Head;

// node_modules/svelte-email/components/Heading.svelte
var file6 = "node_modules/svelte-email/components/Heading.svelte";
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let svelte_element_levels = [
    {
      style: svelte_element_style_value = styleToString({
        ...withMargin({
          m: (
            /*$$props*/
            ctx[2].m
          ),
          mx: (
            /*$$props*/
            ctx[2].mx
          ),
          my: (
            /*$$props*/
            ctx[2].my
          ),
          mt: (
            /*$$props*/
            ctx[2].mt
          ),
          mr: (
            /*$$props*/
            ctx[2].mr
          ),
          mb: (
            /*$$props*/
            ctx[2].mb
          ),
          ml: (
            /*$$props*/
            ctx[2].ml
          )
        }),
        .../*style*/
        ctx[0]
      })
    },
    /*$$restProps*/
    ctx[3]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        { style: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file6, 5, 0, 118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*$$props, style*/
        5 && svelte_element_style_value !== (svelte_element_style_value = styleToString({
          ...withMargin({
            m: (
              /*$$props*/
              ctx2[2].m
            ),
            mx: (
              /*$$props*/
              ctx2[2].mx
            ),
            my: (
              /*$$props*/
              ctx2[2].my
            ),
            mt: (
              /*$$props*/
              ctx2[2].mt
            ),
            mr: (
              /*$$props*/
              ctx2[2].mr
            ),
            mb: (
              /*$$props*/
              ctx2[2].mb
            ),
            ml: (
              /*$$props*/
              ctx2[2].ml
            )
          }),
          .../*style*/
          ctx2[0]
        }))) && { style: svelte_element_style_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(6:0) <svelte:element  this={as}  style={styleToString({   ...withMargin({    m: $$props.m,    mx: $$props.mx,    my: $$props.my,    mt: $$props.mt,    mr: $$props.mr,    mb: $$props.mb,    ml: $$props.ml   }),   ...style  })}  {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["style", "as"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Heading", slots, ["default"]);
  let { style = {} } = $$props;
  let { as = "h1" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("as" in $$new_props)
      $$invalidate(1, as = $$new_props.as);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ styleToString, withMargin, style, as });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("as" in $$props)
      $$invalidate(1, as = $$new_props.as);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [style, as, $$props, $$restProps, $$scope, slots];
}
var Heading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { style: 0, as: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Heading",
      options,
      id: create_fragment6.name
    });
  }
  get style() {
    throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Heading_default = Heading;

// node_modules/svelte-email/components/Hr.svelte
var file7 = "node_modules/svelte-email/components/Hr.svelte";
function create_fragment7(ctx) {
  let hr;
  let hr_style_value;
  let hr_levels = [
    {
      style: hr_style_value = styleToString(
        /*styleDefault*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[1]
  ];
  let hr_data = {};
  for (let i = 0; i < hr_levels.length; i += 1) {
    hr_data = assign(hr_data, hr_levels[i]);
  }
  const block = {
    c: function create() {
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", { style: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(hr, hr_data);
      add_location(hr, file7, 10, 0, 190);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(hr, hr_data = get_spread_update(hr_levels, [
        { style: hr_style_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(hr);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hr", slots, []);
  let { style = {} } = $$props;
  const styleDefault = {
    width: "100%",
    border: "none",
    borderTop: "1px solid #eaeaea",
    ...style
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
  };
  $$self.$capture_state = () => ({ styleToString, style, styleDefault });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [styleDefault, $$restProps, style];
}
var Hr = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { style: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hr",
      options,
      id: create_fragment7.name
    });
  }
  get style() {
    throw new Error("<Hr>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Hr>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hr_default = Hr;

// node_modules/svelte-email/components/Html.svelte
var file8 = "node_modules/svelte-email/components/Html.svelte";
function create_fragment8(ctx) {
  let html;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let html_levels = [
    /*$$restProps*/
    ctx[1],
    { id: "__svelte-email" },
    { lang: (
      /*lang*/
      ctx[0]
    ) }
  ];
  let html_data = {};
  for (let i = 0; i < html_levels.length; i += 1) {
    html_data = assign(html_data, html_levels[i]);
  }
  const block = {
    c: function create() {
      html = element("html");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      html = claim_element(nodes, "HTML", { id: true, lang: true });
      var html_nodes = children(html);
      if (default_slot)
        default_slot.l(html_nodes);
      html_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(html, html_data);
      add_location(html, file8, 3, 0, 43);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, html, anchor);
      if (default_slot) {
        default_slot.m(html, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(html, html_data = get_spread_update(html_levels, [
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1],
        { id: "__svelte-email" },
        (!current || dirty & /*lang*/
        1) && { lang: (
          /*lang*/
          ctx2[0]
        ) }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["lang"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Html", slots, ["default"]);
  let { lang = "en" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("lang" in $$new_props)
      $$invalidate(0, lang = $$new_props.lang);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ lang });
  $$self.$inject_state = ($$new_props) => {
    if ("lang" in $$props)
      $$invalidate(0, lang = $$new_props.lang);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [lang, $$restProps, $$scope, slots];
}
var Html = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { lang: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Html",
      options,
      id: create_fragment8.name
    });
  }
  get lang() {
    throw new Error("<Html>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lang(value) {
    throw new Error("<Html>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Html_default = Html;

// node_modules/svelte-email/components/Img.svelte
var file9 = "node_modules/svelte-email/components/Img.svelte";
function create_fragment9(ctx) {
  let img;
  let img_src_value;
  let img_style_value;
  let img_levels = [
    { alt: (
      /*alt*/
      ctx[0]
    ) },
    { src: img_src_value = /*src*/
    ctx[1] },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    {
      style: img_style_value = styleToString(
        /*styleDefault*/
        ctx[4]
      )
    },
    /*$$restProps*/
    ctx[5]
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        alt: true,
        src: true,
        width: true,
        height: true,
        style: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file9, 15, 0, 295);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*alt*/
        1 && { alt: (
          /*alt*/
          ctx2[0]
        ) },
        dirty & /*src*/
        2 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[1]) && { src: img_src_value },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        { style: img_style_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["style", "alt", "src", "width", "height"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Img", slots, []);
  let { style = {} } = $$props;
  let { alt = "" } = $$props;
  let { src = "" } = $$props;
  let { width = "0" } = $$props;
  let { height = "0" } = $$props;
  const styleDefault = {
    display: "block",
    outline: "none",
    border: "none",
    textDecoration: "none",
    ...style
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(6, style = $$new_props.style);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("width" in $$new_props)
      $$invalidate(2, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
  };
  $$self.$capture_state = () => ({
    styleToString,
    style,
    alt,
    src,
    width,
    height,
    styleDefault
  });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(6, style = $$new_props.style);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("src" in $$props)
      $$invalidate(1, src = $$new_props.src);
    if ("width" in $$props)
      $$invalidate(2, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(3, height = $$new_props.height);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [alt, src, width, height, styleDefault, $$restProps, style];
}
var Img = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      style: 6,
      alt: 0,
      src: 1,
      width: 2,
      height: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Img",
      options,
      id: create_fragment9.name
    });
  }
  get style() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Img_default = Img;

// node_modules/svelte-email/components/Link.svelte
var file10 = "node_modules/svelte-email/components/Link.svelte";
function create_fragment10(ctx) {
  let a;
  let a_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let a_levels = [
    /*$$restProps*/
    ctx[3],
    { href: (
      /*href*/
      ctx[1]
    ) },
    { target: (
      /*target*/
      ctx[0]
    ) },
    {
      style: a_style_value = styleToString(
        /*styleDefault*/
        ctx[2]
      )
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, target: true, style: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file10, 11, 0, 219);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3],
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*target*/
        1) && { target: (
          /*target*/
          ctx2[0]
        ) },
        { style: a_style_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["style", "target", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Link", slots, ["default"]);
  let { style = {} } = $$props;
  let { target = "_blank" } = $$props;
  let { href = "" } = $$props;
  const styleDefault = {
    color: "#067df7",
    textDecoration: "none",
    ...style
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("target" in $$new_props)
      $$invalidate(0, target = $$new_props.target);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    styleToString,
    style,
    target,
    href,
    styleDefault
  });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("target" in $$props)
      $$invalidate(0, target = $$new_props.target);
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [target, href, styleDefault, $$restProps, style, $$scope, slots];
}
var Link = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { style: 4, target: 0, href: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link",
      options,
      id: create_fragment10.name
    });
  }
  get style() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Link_default = Link;

// node_modules/svelte-email/components/Preview.svelte
var file11 = "node_modules/svelte-email/components/Preview.svelte";
function create_fragment11(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let t2_value = (
    /*renderWhiteSpace*/
    ctx[1](
      /*preview*/
      ctx[0]
    ) + ""
  );
  let t2;
  let div1_style_value;
  let div1_levels = [
    { id: "__svelte-email-preview" },
    {
      style: div1_style_value = styleToString({
        display: "none",
        overflow: "hidden",
        lineHeight: "1px",
        opacity: 0,
        maxHeight: 0,
        maxWidth: 0
      })
    },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      t0 = text(
        /*preview*/
        ctx[0]
      );
      t1 = space();
      div0 = element("div");
      t2 = text(t2_value);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { id: true, style: true });
      var div1_nodes = children(div1);
      t0 = claim_text(
        div1_nodes,
        /*preview*/
        ctx[0]
      );
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      t2 = claim_text(div0_nodes, t2_value);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div0, file11, 21, 1, 449);
      set_attributes(div1, div_data_1);
      add_location(div1, file11, 8, 0, 248);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*preview*/
      1)
        set_data_maybe_contenteditable_dev(
          t0,
          /*preview*/
          ctx2[0],
          div_data_1["contenteditable"]
        );
      if (dirty & /*preview*/
      1 && t2_value !== (t2_value = /*renderWhiteSpace*/
      ctx2[1](
        /*preview*/
        ctx2[0]
      ) + ""))
        set_data_dev(t2, t2_value);
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        { id: "__svelte-email-preview" },
        { style: div1_style_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = ["preview"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Preview", slots, []);
  let { preview = "" } = $$props;
  const renderWhiteSpace = (text2) => {
    const whiteSpaceCodes = " ‌​‍‎‏\uFEFF";
    return whiteSpaceCodes.repeat(150 - text2.length);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("preview" in $$new_props)
      $$invalidate(0, preview = $$new_props.preview);
  };
  $$self.$capture_state = () => ({ styleToString, preview, renderWhiteSpace });
  $$self.$inject_state = ($$new_props) => {
    if ("preview" in $$props)
      $$invalidate(0, preview = $$new_props.preview);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [preview, renderWhiteSpace, $$restProps];
}
var Preview = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { preview: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Preview",
      options,
      id: create_fragment11.name
    });
  }
  get preview() {
    throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preview(value) {
    throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Preview_default = Preview;

// node_modules/svelte-email/components/Section.svelte
var file12 = "node_modules/svelte-email/components/Section.svelte";
function create_fragment12(ctx) {
  let table;
  let tbody;
  let tr;
  let tr_style_value;
  let table_style_value;
  let table_border_value;
  let table_cellpadding_value;
  let table_cellspacing_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let table_levels = [
    {
      style: table_style_value = styleToString(
        /*styleDefaultTable*/
        ctx[0]
      )
    },
    { align: "center" },
    { border: table_border_value = 0 },
    { cellpadding: table_cellpadding_value = 0 },
    { cellspacing: table_cellspacing_value = 0 },
    { role: "presentation" },
    /*$$restProps*/
    ctx[2]
  ];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      tbody = element("tbody");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", {
        style: true,
        align: true,
        border: true,
        cellpadding: true,
        cellspacing: true,
        role: true
      });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      tr = claim_element(tbody_nodes, "TR", { style: true });
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "style", tr_style_value = styleToString(
        /*styleDefaultTr*/
        ctx[1]
      ));
      add_location(tr, file12, 23, 2, 415);
      add_location(tbody, file12, 22, 1, 405);
      set_attributes(table, table_data);
      add_location(table, file12, 13, 0, 252);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, tbody);
      append_hydration_dev(tbody, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        { style: table_style_value },
        { align: "center" },
        { border: table_border_value },
        { cellpadding: table_cellpadding_value },
        { cellspacing: table_cellspacing_value },
        { role: "presentation" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(table);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  let { style = {} } = $$props;
  const styleDefaultTable = { width: "100%", ...style };
  const styleDefaultTr = {
    display: "grid",
    gridAutoColumns: "minmax(0, 1fr)",
    gridAutoFlow: "column"
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    styleToString,
    style,
    styleDefaultTable,
    styleDefaultTr
  });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(3, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [styleDefaultTable, styleDefaultTr, $$restProps, style, $$scope, slots];
}
var Section = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { style: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment12.name
    });
  }
  get style() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Section_default = Section;

// node_modules/svelte-email/components/Text.svelte
var file13 = "node_modules/svelte-email/components/Text.svelte";
function create_fragment13(ctx) {
  let p;
  let p_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let p_levels = [
    {
      style: p_style_value = styleToString(
        /*styleDefault*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[1]
  ];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { style: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(p, p_data);
      add_location(p, file13, 10, 0, 183);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        { style: p_style_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = ["style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { style = {} } = $$props;
  const styleDefault = {
    fontSize: "14px",
    lineHeight: "24px",
    margin: "16px 0",
    ...style
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ styleToString, style, styleDefault });
  $$self.$inject_state = ($$new_props) => {
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [styleDefault, $$restProps, style, $$scope, slots];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { style: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment13.name
    });
  }
  get style() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/svelte-email/render.js
var import_pretty = __toESM(require_pretty(), 1);
var render = ({ template, props, options }) => {
  const { html } = (
    // @ts-ignore
    template.render(props)
  );
  if (options == null ? void 0 : options.plainText) {
    return renderAsPlainText(html);
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const markup = html;
  const document = `${doctype}${markup}`;
  if (options == null ? void 0 : options.pretty) {
    return (0, import_pretty.default)(document);
  }
  return document;
};
var renderAsPlainText = (markup) => {
  return convert(markup, {
    selectors: [
      { selector: "img", format: "skip" },
      { selector: "#__svelte-email-preview", format: "skip" }
    ]
  });
};
export {
  Body_default as Body,
  Button_default as Button,
  Column_default as Column,
  Container_default as Container,
  Head_default as Head,
  Heading_default as Heading,
  Hr_default as Hr,
  Html_default as Html,
  Img_default as Img,
  Link_default as Link,
  Preview_default as Preview,
  Section_default as Section,
  Text_default as Text,
  render,
  styleToString
};
//# sourceMappingURL=svelte-email.js.map
