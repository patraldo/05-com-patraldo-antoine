import {
  ChevronDown_default
} from "./chunk-HJZIWFMJ.js";
import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-IPC4YNSI.js";
import "./chunk-3YG4HVQA.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  afterUpdate,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_style,
  set_svg_attributes,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-4HN6M6VN.js";
import "./chunk-ZJ46KODL.js";
import "./chunk-2B2CG5KL.js";

// node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte
var file = "node_modules/carbon-components-svelte/src/Toggle/Toggle.svelte";
var get_labelB_slot_changes = (dirty) => ({});
var get_labelB_slot_context = (ctx) => ({});
var get_labelA_slot_changes = (dirty) => ({});
var get_labelA_slot_context = (ctx) => ({});
var get_labelText_slot_changes = (dirty) => ({});
var get_labelText_slot_context = (ctx) => ({});
function fallback_block_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelText*/
      32)
        set_data_dev(
          t,
          /*labelText*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(87:29)          ",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelA*/
        ctx[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelA*/
        ctx[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelA*/
      8)
        set_data_dev(
          t,
          /*labelA*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(96:28)            ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelB*/
        ctx[4]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelB*/
        ctx[4]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*labelB*/
      16)
        set_data_dev(
          t,
          /*labelB*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(101:28)            ",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let input;
  let t0;
  let label;
  let span0;
  let t1;
  let span3;
  let span1;
  let t2;
  let span2;
  let label_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const labelText_slot_template = (
    /*#slots*/
    ctx[12].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelText_slot_context
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block_2(ctx);
  const labelA_slot_template = (
    /*#slots*/
    ctx[12].labelA
  );
  const labelA_slot = create_slot(
    labelA_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelA_slot_context
  );
  const labelA_slot_or_fallback = labelA_slot || fallback_block_1(ctx);
  const labelB_slot_template = (
    /*#slots*/
    ctx[12].labelB
  );
  const labelB_slot = create_slot(
    labelB_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_labelB_slot_context
  );
  const labelB_slot_or_fallback = labelB_slot || fallback_block(ctx);
  let div_levels = [
    /*$$restProps*/
    ctx[9]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      span0 = element("span");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      t1 = space();
      span3 = element("span");
      span1 = element("span");
      if (labelA_slot_or_fallback)
        labelA_slot_or_fallback.c();
      t2 = space();
      span2 = element("span");
      if (labelB_slot_or_fallback)
        labelB_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        role: true,
        type: true,
        id: true,
        name: true
      });
      t0 = claim_space(div_nodes);
      label = claim_element(div_nodes, "LABEL", { "aria-label": true, for: true });
      var label_nodes = children(label);
      span0 = claim_element(label_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(label_nodes);
      span3 = claim_element(label_nodes, "SPAN", {});
      var span3_nodes = children(span3);
      span1 = claim_element(span3_nodes, "SPAN", { "aria-hidden": true });
      var span1_nodes = children(span1);
      if (labelA_slot_or_fallback)
        labelA_slot_or_fallback.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(span3_nodes);
      span2 = claim_element(span3_nodes, "SPAN", { "aria-hidden": true });
      var span2_nodes = children(span2);
      if (labelB_slot_or_fallback)
        labelB_slot_or_fallback.l(span2_nodes);
      span2_nodes.forEach(detach_dev);
      span3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "role", "switch");
      attr_dev(input, "type", "checkbox");
      input.checked = /*toggled*/
      ctx[0];
      input.disabled = /*disabled*/
      ctx[2];
      attr_dev(
        input,
        "id",
        /*id*/
        ctx[7]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[8]
      );
      toggle_class(input, "bx--toggle-input", true);
      toggle_class(
        input,
        "bx--toggle-input--small",
        /*size*/
        ctx[1] === "sm"
      );
      add_location(input, file, 57, 2, 1319);
      toggle_class(
        span0,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[6]
      );
      add_location(span0, file, 85, 4, 1945);
      attr_dev(span1, "aria-hidden", "true");
      toggle_class(span1, "bx--toggle__text--off", true);
      add_location(span1, file, 94, 6, 2183);
      attr_dev(span2, "aria-hidden", "true");
      toggle_class(span2, "bx--toggle__text--on", true);
      add_location(span2, file, 99, 6, 2330);
      toggle_class(span3, "bx--toggle__switch", true);
      set_style(
        span3,
        "margin-top",
        /*hideLabel*/
        ctx[6] ? 0 : void 0
      );
      add_location(span3, file, 90, 4, 2072);
      attr_dev(label, "aria-label", label_aria_label_value = /*labelText*/
      ctx[5] ? void 0 : (
        /*$$props*/
        ctx[10]["aria-label"] || "Toggle"
      ));
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[7]
      );
      toggle_class(label, "bx--toggle-input__label", true);
      add_location(label, file, 80, 2, 1795);
      set_attributes(div, div_data);
      toggle_class(div, "bx--form-item", true);
      set_style(div, "user-select", `none`);
      add_location(div, file, 47, 0, 1116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, label);
      append_hydration_dev(label, span0);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(span0, null);
      }
      append_hydration_dev(label, t1);
      append_hydration_dev(label, span3);
      append_hydration_dev(span3, span1);
      if (labelA_slot_or_fallback) {
        labelA_slot_or_fallback.m(span1, null);
      }
      append_hydration_dev(span3, t2);
      append_hydration_dev(span3, span2);
      if (labelB_slot_or_fallback) {
        labelB_slot_or_fallback.m(span2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*mouseover_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*toggled*/
      1) {
        prop_dev(
          input,
          "checked",
          /*toggled*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*name*/
      256) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*size*/
      2) {
        toggle_class(
          input,
          "bx--toggle-input--small",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelText_slot_changes
            ),
            get_labelText_slot_context
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty & /*labelText*/
        32)) {
          labelText_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*hideLabel*/
      64) {
        toggle_class(
          span0,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[6]
        );
      }
      if (labelA_slot) {
        if (labelA_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelA_slot,
            labelA_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelA_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelA_slot_changes
            ),
            get_labelA_slot_context
          );
        }
      } else {
        if (labelA_slot_or_fallback && labelA_slot_or_fallback.p && (!current || dirty & /*labelA*/
        8)) {
          labelA_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (labelB_slot) {
        if (labelB_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            labelB_slot,
            labelB_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              labelB_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_labelB_slot_changes
            ),
            get_labelB_slot_context
          );
        }
      } else {
        if (labelB_slot_or_fallback && labelB_slot_or_fallback.p && (!current || dirty & /*labelB*/
        16)) {
          labelB_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (dirty & /*hideLabel*/
      64) {
        set_style(
          span3,
          "margin-top",
          /*hideLabel*/
          ctx2[6] ? 0 : void 0
        );
      }
      if (!current || dirty & /*labelText, $$props*/
      1056 && label_aria_label_value !== (label_aria_label_value = /*labelText*/
      ctx2[5] ? void 0 : (
        /*$$props*/
        ctx2[10]["aria-label"] || "Toggle"
      ))) {
        attr_dev(label, "aria-label", label_aria_label_value);
      }
      if (!current || dirty & /*id*/
      128) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[7]
        );
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      512 && /*$$restProps*/
      ctx2[9]]));
      toggle_class(div, "bx--form-item", true);
      set_style(div, "user-select", `none`);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      transition_in(labelA_slot_or_fallback, local);
      transition_in(labelB_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      transition_out(labelA_slot_or_fallback, local);
      transition_out(labelB_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
      if (labelA_slot_or_fallback)
        labelA_slot_or_fallback.d(detaching);
      if (labelB_slot_or_fallback)
        labelB_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "size",
    "toggled",
    "disabled",
    "labelA",
    "labelB",
    "labelText",
    "hideLabel",
    "id",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toggle", slots, ["labelText", "labelA", "labelB"]);
  let { size = "default" } = $$props;
  let { toggled = false } = $$props;
  let { disabled = false } = $$props;
  let { labelA = "Off" } = $$props;
  let { labelB = "On" } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  const change_handler_1 = () => {
    $$invalidate(0, toggled = !toggled);
  };
  const keyup_handler_1 = (e) => {
    if (e.key === " " || e.key === "Enter") {
      e.preventDefault();
      $$invalidate(0, toggled = !toggled);
    }
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("toggled" in $$new_props)
      $$invalidate(0, toggled = $$new_props.toggled);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("labelA" in $$new_props)
      $$invalidate(3, labelA = $$new_props.labelA);
    if ("labelB" in $$new_props)
      $$invalidate(4, labelB = $$new_props.labelB);
    if ("labelText" in $$new_props)
      $$invalidate(5, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(6, hideLabel = $$new_props.hideLabel);
    if ("id" in $$new_props)
      $$invalidate(7, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(8, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    size,
    toggled,
    disabled,
    labelA,
    labelB,
    labelText,
    hideLabel,
    id,
    name,
    createEventDispatcher,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("toggled" in $$props)
      $$invalidate(0, toggled = $$new_props.toggled);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("labelA" in $$props)
      $$invalidate(3, labelA = $$new_props.labelA);
    if ("labelB" in $$props)
      $$invalidate(4, labelB = $$new_props.labelB);
    if ("labelText" in $$props)
      $$invalidate(5, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(6, hideLabel = $$new_props.hideLabel);
    if ("id" in $$props)
      $$invalidate(7, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(8, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*toggled*/
    1) {
      $:
        dispatch("toggle", { toggled });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    toggled,
    size,
    disabled,
    labelA,
    labelB,
    labelText,
    hideLabel,
    id,
    name,
    $$restProps,
    $$props,
    $$scope,
    slots,
    click_handler,
    mouseover_handler,
    mouseenter_handler,
    mouseleave_handler,
    change_handler,
    keyup_handler,
    focus_handler,
    blur_handler,
    change_handler_1,
    keyup_handler_1
  ];
}
var Toggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      size: 1,
      toggled: 0,
      disabled: 2,
      labelA: 3,
      labelB: 4,
      labelText: 5,
      hideLabel: 6,
      id: 7,
      name: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toggle",
      options,
      id: create_fragment.name
    });
  }
  get size() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelA() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelA(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelB() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelB(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toggle_default = Toggle;

// node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte
var file2 = "node_modules/carbon-components-svelte/src/icons/WarningFilled.svelte";
function create_if_block(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file2, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data_dev(
          t,
          /*title*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let svg;
  let path0;
  let path1;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true,
        opacity: true
      });
      children(path1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M16,2C8.3,2,2,8.3,2,16s6.3,14,14,14s14-6.3,14-14C30,8.3,23.7,2,16,2z M14.9,8h2.2v11h-2.2V8z M16,25	c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22c0.8,0,1.5,0.7,1.5,1.5S16.8,25,16,25z");
      add_location(path0, file2, 24, 2, 579);
      attr_dev(path1, "fill", "none");
      attr_dev(path1, "d", "M17.5,23.5c0,0.8-0.7,1.5-1.5,1.5c-0.8,0-1.5-0.7-1.5-1.5S15.2,22,16,22	C16.8,22,17.5,22.7,17.5,23.5z M17.1,8h-2.2v11h2.2V8z");
      attr_dev(path1, "data-icon-path", "inner-path");
      attr_dev(path1, "opacity", "0");
      add_location(path1, file2, 26, 10, 777);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file2, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WarningFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var WarningFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WarningFilled",
      options,
      id: create_fragment2.name
    });
  }
  get size() {
    throw new Error("<WarningFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WarningFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<WarningFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<WarningFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WarningFilled_default = WarningFilled;

// node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte
var file3 = "node_modules/carbon-components-svelte/src/icons/WarningAltFilled.svelte";
function create_if_block2(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(
        title_1_nodes,
        /*title*/
        ctx[1]
      );
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file3, 23, 13, 549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2)
        set_data_dev(
          t,
          /*title*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(title_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(24:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let svg;
  let path0;
  let path1;
  let path2;
  let if_block = (
    /*title*/
    ctx[1] && create_if_block2(ctx)
  );
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 32 32" },
    { fill: "currentColor" },
    { preserveAspectRatio: "xMidYMid meet" },
    { width: (
      /*size*/
      ctx[0]
    ) },
    { height: (
      /*size*/
      ctx[0]
    ) },
    /*attributes*/
    ctx[2],
    /*$$restProps*/
    ctx[3]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        viewBox: true,
        fill: true,
        preserveAspectRatio: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path0 = claim_svg_element(svg_nodes, "path", {
        fill: true,
        d: true,
        "data-icon-path": true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(svg_nodes, "path", { d: true });
      children(path2).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "fill", "none");
      attr_dev(path0, "d", "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z");
      attr_dev(path0, "data-icon-path", "inner-path");
      add_location(path0, file3, 24, 2, 579);
      attr_dev(path1, "d", "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z");
      add_location(path1, file3, 27, 39, 722);
      attr_dev(path2, "d", "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z");
      add_location(path2, file3, 29, 10, 886);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file3, 13, 0, 338);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path0);
      append_hydration_dev(svg, path1);
      append_hydration_dev(svg, path2);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(svg, path0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 32 32" },
        { fill: "currentColor" },
        { preserveAspectRatio: "xMidYMid meet" },
        dirty & /*size*/
        1 && { width: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*size*/
        1 && { height: (
          /*size*/
          ctx2[0]
        ) },
        dirty & /*attributes*/
        4 && /*attributes*/
        ctx2[2],
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let labelled;
  let attributes;
  const omit_props_names = ["size", "title"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WarningAltFilled", slots, []);
  let { size = 16 } = $$props;
  let { title = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("size" in $$new_props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
  };
  $$self.$capture_state = () => ({ size, title, labelled, attributes });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("size" in $$props)
      $$invalidate(0, size = $$new_props.size);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("labelled" in $$props)
      $$invalidate(4, labelled = $$new_props.labelled);
    if ("attributes" in $$props)
      $$invalidate(2, attributes = $$new_props.attributes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, labelled = $$props["aria-label"] || $$props["aria-labelledby"] || title);
    $:
      $$invalidate(2, attributes = {
        "aria-hidden": labelled ? void 0 : true,
        role: labelled ? "img" : void 0,
        focusable: Number($$props["tabindex"]) === 0 ? true : void 0
      });
  };
  $$props = exclude_internal_props($$props);
  return [size, title, attributes, $$restProps, labelled];
}
var WarningAltFilled = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { size: 0, title: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WarningAltFilled",
      options,
      id: create_fragment3.name
    });
  }
  get size() {
    throw new Error("<WarningAltFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<WarningAltFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<WarningAltFilled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<WarningAltFilled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WarningAltFilled_default = WarningAltFilled;

// node_modules/carbon-components-svelte/src/Select/Select.svelte
var file4 = "node_modules/carbon-components-svelte/src/Select/Select.svelte";
var get_labelText_slot_changes2 = (dirty) => ({});
var get_labelText_slot_context2 = (ctx) => ({});
function create_if_block_10(ctx) {
  let label;
  let current;
  const labelText_slot_template = (
    /*#slots*/
    ctx[26].labelText
  );
  const labelText_slot = create_slot(
    labelText_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_labelText_slot_context2
  );
  const labelText_slot_or_fallback = labelText_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      label = element("label");
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { for: true });
      var label_nodes = children(label);
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label,
        "for",
        /*id*/
        ctx[5]
      );
      toggle_class(label, "bx--label", true);
      toggle_class(
        label,
        "bx--visually-hidden",
        /*hideLabel*/
        ctx[14]
      );
      toggle_class(
        label,
        "bx--label--disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(label, file4, 136, 6, 3412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (labelText_slot_or_fallback) {
        labelText_slot_or_fallback.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (labelText_slot) {
        if (labelText_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            labelText_slot,
            labelText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              labelText_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_labelText_slot_changes2
            ),
            get_labelText_slot_context2
          );
        }
      } else {
        if (labelText_slot_or_fallback && labelText_slot_or_fallback.p && (!current || dirty[0] & /*labelText*/
        8192)) {
          labelText_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*id*/
      32) {
        attr_dev(
          label,
          "for",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*hideLabel*/
      16384) {
        toggle_class(
          label,
          "bx--visually-hidden",
          /*hideLabel*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16) {
        toggle_class(
          label,
          "bx--label--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelText_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelText_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (labelText_slot_or_fallback)
        labelText_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(136:4) {#if !noLabel}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*labelText*/
        ctx[13]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*labelText*/
        ctx[13]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*labelText*/
      8192)
        set_data_dev(
          t,
          /*labelText*/
          ctx2[13]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(143:31)            ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div1;
  let div0;
  let select;
  let select_aria_describedby_value;
  let select_aria_invalid_value;
  let select_disabled_value;
  let select_required_value;
  let t0;
  let chevrondown;
  let t1;
  let div0_data_invalid_value;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  chevrondown = new ChevronDown_default({
    props: { class: "bx--select__arrow" },
    $$inline: true
  });
  let if_block0 = (
    /*invalid*/
    ctx[7] && create_if_block_9(ctx)
  );
  let if_block1 = (
    /*invalid*/
    ctx[7] && create_if_block_8(ctx)
  );
  let if_block2 = !/*invalid*/
  ctx[7] && !/*warn*/
  ctx[9] && /*helperText*/
  ctx[11] && create_if_block_7(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      select = element("select");
      if (default_slot)
        default_slot.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { "data-invalid": true });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", {
        "aria-describedby": true,
        "aria-invalid": true,
        id: true,
        name: true
      });
      var select_nodes = children(select);
      if (default_slot)
        default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      t0 = claim_space(div0_nodes);
      claim_component(chevrondown.$$.fragment, div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "aria-describedby", select_aria_describedby_value = /*invalid*/
      ctx[7] ? (
        /*errorId*/
        ctx[16]
      ) : void 0);
      attr_dev(select, "aria-invalid", select_aria_invalid_value = /*invalid*/
      ctx[7] || void 0);
      select.disabled = select_disabled_value = /*disabled*/
      ctx[4] || void 0;
      select.required = select_required_value = /*required*/
      ctx[15] || void 0;
      attr_dev(
        select,
        "id",
        /*id*/
        ctx[5]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[6]
      );
      toggle_class(select, "bx--select-input", true);
      toggle_class(
        select,
        "bx--select-input--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        select,
        "bx--select-input--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(select, file4, 153, 10, 3879);
      attr_dev(div0, "data-invalid", div0_data_invalid_value = /*invalid*/
      ctx[7] || void 0);
      toggle_class(div0, "bx--select-input__wrapper", true);
      add_location(div0, file4, 149, 8, 3755);
      toggle_class(div1, "bx--select-input--inline__wrapper", true);
      add_location(div1, file4, 148, 6, 3692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      ctx[35](select);
      append_hydration_dev(div0, t0);
      mount_component(chevrondown, div0, null);
      append_hydration_dev(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*handleChange*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*change_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*input_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "focus",
            /*focus_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*blur_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*invalid, errorId*/
      65664 && select_aria_describedby_value !== (select_aria_describedby_value = /*invalid*/
      ctx2[7] ? (
        /*errorId*/
        ctx2[16]
      ) : void 0)) {
        attr_dev(select, "aria-describedby", select_aria_describedby_value);
      }
      if (!current || dirty[0] & /*invalid*/
      128 && select_aria_invalid_value !== (select_aria_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(select, "aria-invalid", select_aria_invalid_value);
      }
      if (!current || dirty[0] & /*disabled*/
      16 && select_disabled_value !== (select_disabled_value = /*disabled*/
      ctx2[4] || void 0)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (!current || dirty[0] & /*required*/
      32768 && select_required_value !== (select_required_value = /*required*/
      ctx2[15] || void 0)) {
        prop_dev(select, "required", select_required_value);
      }
      if (!current || dirty[0] & /*id*/
      32) {
        attr_dev(
          select,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*name*/
      64) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--sm",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--xl",
          /*size*/
          ctx2[1] === "xl"
        );
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid*/
      128 && div0_data_invalid_value !== (div0_data_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(div0, "data-invalid", div0_data_invalid_value);
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!/*invalid*/
      ctx2[7] && !/*warn*/
      ctx2[9] && /*helperText*/
      ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_7(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t3);
        detach_dev(if_block2_anchor);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[35](null);
      destroy_component(chevrondown);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(148:4) {#if inline}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--select__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(174:10) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[8]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[8]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file4, 178, 10, 4708);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      256)
        set_data_dev(
          t,
          /*invalidText*/
          ctx2[8]
        );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(178:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div, file4, 184, 8, 4887);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048)
        set_data_dev(
          t,
          /*helperText*/
          ctx2[11]
        );
      if (dirty[0] & /*disabled*/
      16) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(184:6) {#if !invalid && !warn && helperText}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let select;
  let select_aria_describedby_value;
  let select_disabled_value;
  let select_required_value;
  let select_aria_invalid_value;
  let t0;
  let chevrondown;
  let t1;
  let t2;
  let div_data_invalid_value;
  let t3;
  let t4;
  let t5;
  let if_block4_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  chevrondown = new ChevronDown_default({
    props: { class: "bx--select__arrow" },
    $$inline: true
  });
  let if_block0 = (
    /*invalid*/
    ctx[7] && create_if_block_5(ctx)
  );
  let if_block1 = !/*invalid*/
  ctx[7] && /*warn*/
  ctx[9] && create_if_block_4(ctx);
  let if_block2 = !/*invalid*/
  ctx[7] && /*helperText*/
  ctx[11] && create_if_block_3(ctx);
  let if_block3 = (
    /*invalid*/
    ctx[7] && create_if_block_2(ctx)
  );
  let if_block4 = !/*invalid*/
  ctx[7] && /*warn*/
  ctx[9] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      select = element("select");
      if (default_slot)
        default_slot.c();
      t0 = space();
      create_component(chevrondown.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-invalid": true });
      var div_nodes = children(div);
      select = claim_element(div_nodes, "SELECT", {
        id: true,
        name: true,
        "aria-describedby": true,
        "aria-invalid": true
      });
      var select_nodes = children(select);
      if (default_slot)
        default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      claim_component(chevrondown.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t4 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t5 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      if_block4_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        select,
        "id",
        /*id*/
        ctx[5]
      );
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[6]
      );
      attr_dev(select, "aria-describedby", select_aria_describedby_value = /*invalid*/
      ctx[7] ? (
        /*errorId*/
        ctx[16]
      ) : void 0);
      select.disabled = select_disabled_value = /*disabled*/
      ctx[4] || void 0;
      select.required = select_required_value = /*required*/
      ctx[15] || void 0;
      attr_dev(select, "aria-invalid", select_aria_invalid_value = /*invalid*/
      ctx[7] || void 0);
      toggle_class(select, "bx--select-input", true);
      toggle_class(
        select,
        "bx--select-input--sm",
        /*size*/
        ctx[1] === "sm"
      );
      toggle_class(
        select,
        "bx--select-input--xl",
        /*size*/
        ctx[1] === "xl"
      );
      add_location(select, file4, 197, 8, 5210);
      attr_dev(div, "data-invalid", div_data_invalid_value = /*invalid*/
      ctx[7] || void 0);
      toggle_class(div, "bx--select-input__wrapper", true);
      add_location(div, file4, 193, 6, 5094);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, select);
      if (default_slot) {
        default_slot.m(select, null);
      }
      ctx[36](select);
      append_hydration_dev(div, t0);
      mount_component(chevrondown, div, null);
      append_hydration_dev(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, if_block4_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*handleChange*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "change",
            /*change_handler_1*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "input",
            /*input_handler_1*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "focus",
            /*focus_handler_1*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select,
            "blur",
            /*blur_handler_1*/
            ctx[30],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*id*/
      32) {
        attr_dev(
          select,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*name*/
      64) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*invalid, errorId*/
      65664 && select_aria_describedby_value !== (select_aria_describedby_value = /*invalid*/
      ctx2[7] ? (
        /*errorId*/
        ctx2[16]
      ) : void 0)) {
        attr_dev(select, "aria-describedby", select_aria_describedby_value);
      }
      if (!current || dirty[0] & /*disabled*/
      16 && select_disabled_value !== (select_disabled_value = /*disabled*/
      ctx2[4] || void 0)) {
        prop_dev(select, "disabled", select_disabled_value);
      }
      if (!current || dirty[0] & /*required*/
      32768 && select_required_value !== (select_required_value = /*required*/
      ctx2[15] || void 0)) {
        prop_dev(select, "required", select_required_value);
      }
      if (!current || dirty[0] & /*invalid*/
      128 && select_aria_invalid_value !== (select_aria_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(select, "aria-invalid", select_aria_invalid_value);
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--sm",
          /*size*/
          ctx2[1] === "sm"
        );
      }
      if (!current || dirty[0] & /*size*/
      2) {
        toggle_class(
          select,
          "bx--select-input--xl",
          /*size*/
          ctx2[1] === "xl"
        );
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block0) {
          if (dirty[0] & /*invalid*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*invalid*/
      ctx2[7] && /*warn*/
      ctx2[9]) {
        if (if_block1) {
          if (dirty[0] & /*invalid, warn*/
          640) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*invalid*/
      128 && div_data_invalid_value !== (div_data_invalid_value = /*invalid*/
      ctx2[7] || void 0)) {
        attr_dev(div, "data-invalid", div_data_invalid_value);
      }
      if (!/*invalid*/
      ctx2[7] && /*helperText*/
      ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_3(ctx2);
          if_block2.c();
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*invalid*/
        ctx2[7]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_2(ctx2);
          if_block3.c();
          if_block3.m(t5.parentNode, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!/*invalid*/
      ctx2[7] && /*warn*/
      ctx2[9]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1(ctx2);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(chevrondown.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(chevrondown.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(if_block4_anchor);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[36](null);
      destroy_component(chevrondown);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(193:4) {#if !inline}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let warningfilled;
  let current;
  warningfilled = new WarningFilled_default({
    props: { class: "bx--select__invalid-icon" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(218:8) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let warningaltfilled;
  let current;
  warningaltfilled = new WarningAltFilled_default({
    props: {
      class: "bx--select__invalid-icon bx--select__invalid-icon--warning"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(warningaltfilled.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(warningaltfilled.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(warningaltfilled, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(warningaltfilled.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(warningaltfilled.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(warningaltfilled, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(221:8) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*helperText*/
        ctx[11]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*helperText*/
        ctx[11]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div, "bx--form__helper-text", true);
      toggle_class(
        div,
        "bx--form__helper-text--disabled",
        /*disabled*/
        ctx[4]
      );
      add_location(div, file4, 227, 8, 6169);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*helperText*/
      2048)
        set_data_dev(
          t,
          /*helperText*/
          ctx2[11]
        );
      if (dirty[0] & /*disabled*/
      16) {
        toggle_class(
          div,
          "bx--form__helper-text--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(227:6) {#if !invalid && helperText}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*invalidText*/
        ctx[8]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*invalidText*/
        ctx[8]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file4, 235, 8, 6370);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*invalidText*/
      256)
        set_data_dev(
          t,
          /*invalidText*/
          ctx2[8]
        );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(235:6) {#if invalid}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*warnText*/
        ctx[10]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*warnText*/
        ctx[10]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*errorId*/
        ctx[16]
      );
      toggle_class(div, "bx--form-requirement", true);
      add_location(div, file4, 240, 8, 6515);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*warnText*/
      1024)
        set_data_dev(
          t,
          /*warnText*/
          ctx2[10]
        );
      if (dirty[0] & /*errorId*/
      65536) {
        attr_dev(
          div,
          "id",
          /*errorId*/
          ctx2[16]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(240:6) {#if !invalid && warn}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let current;
  let if_block0 = !/*noLabel*/
  ctx[12] && create_if_block_10(ctx);
  let if_block1 = (
    /*inline*/
    ctx[2] && create_if_block_6(ctx)
  );
  let if_block2 = !/*inline*/
  ctx[2] && create_if_block3(ctx);
  let div1_levels = [
    /*$$restProps*/
    ctx[22]
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      toggle_class(div0, "bx--select", true);
      toggle_class(
        div0,
        "bx--select--inline",
        /*inline*/
        ctx[2]
      );
      toggle_class(
        div0,
        "bx--select--light",
        /*light*/
        ctx[3]
      );
      toggle_class(
        div0,
        "bx--select--invalid",
        /*invalid*/
        ctx[7]
      );
      toggle_class(
        div0,
        "bx--select--disabled",
        /*disabled*/
        ctx[4]
      );
      toggle_class(
        div0,
        "bx--select--warning",
        /*warn*/
        ctx[9]
      );
      add_location(div0, file4, 127, 2, 3145);
      set_attributes(div1, div_data_1);
      toggle_class(div1, "bx--form-item", true);
      add_location(div1, file4, 126, 0, 3091);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*noLabel*/
      ctx2[12]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*noLabel*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*inline*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*inline*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!/*inline*/
      ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*inline*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block3(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*inline*/
      4) {
        toggle_class(
          div0,
          "bx--select--inline",
          /*inline*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*light*/
      8) {
        toggle_class(
          div0,
          "bx--select--light",
          /*light*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*invalid*/
      128) {
        toggle_class(
          div0,
          "bx--select--invalid",
          /*invalid*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16) {
        toggle_class(
          div0,
          "bx--select--disabled",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*warn*/
      512) {
        toggle_class(
          div0,
          "bx--select--warning",
          /*warn*/
          ctx2[9]
        );
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [dirty[0] & /*$$restProps*/
      4194304 && /*$$restProps*/
      ctx2[22]]));
      toggle_class(div1, "bx--form-item", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let errorId;
  const omit_props_names = [
    "selected",
    "size",
    "inline",
    "light",
    "disabled",
    "id",
    "name",
    "invalid",
    "invalidText",
    "warn",
    "warnText",
    "helperText",
    "noLabel",
    "labelText",
    "hideLabel",
    "ref",
    "required"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $defaultValue;
  let $selectedValue;
  let $itemTypesByValue;
  let $defaultSelectId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["labelText", "default"]);
  let { selected = void 0 } = $$props;
  let { size = void 0 } = $$props;
  let { inline = false } = $$props;
  let { light = false } = $$props;
  let { disabled = false } = $$props;
  let { id = "ccs-" + Math.random().toString(36) } = $$props;
  let { name = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { invalidText = "" } = $$props;
  let { warn = false } = $$props;
  let { warnText = "" } = $$props;
  let { helperText = "" } = $$props;
  let { noLabel = false } = $$props;
  let { labelText = "" } = $$props;
  let { hideLabel = false } = $$props;
  let { ref = null } = $$props;
  let { required = false } = $$props;
  const dispatch = createEventDispatcher();
  const selectedValue = writable(selected);
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value) => $$invalidate(38, $selectedValue = value));
  const defaultSelectId = writable(null);
  validate_store(defaultSelectId, "defaultSelectId");
  component_subscribe($$self, defaultSelectId, (value) => $$invalidate(40, $defaultSelectId = value));
  const defaultValue = writable(null);
  validate_store(defaultValue, "defaultValue");
  component_subscribe($$self, defaultValue, (value) => $$invalidate(24, $defaultValue = value));
  const itemTypesByValue = writable({});
  validate_store(itemTypesByValue, "itemTypesByValue");
  component_subscribe($$self, itemTypesByValue, (value) => $$invalidate(39, $itemTypesByValue = value));
  setContext("Select", {
    selectedValue,
    setDefaultValue: (id2, value) => {
      if ($defaultValue === null) {
        defaultSelectId.set(id2);
        defaultValue.set(value);
      } else {
        if ($defaultSelectId === id2) {
          selectedValue.set(value);
        }
      }
      itemTypesByValue.update((types) => ({ ...types, [value]: typeof value }));
    }
  });
  const handleChange = ({ target }) => {
    let value = target.value;
    if ($itemTypesByValue[value] === "number") {
      value = Number(value);
    }
    selectedValue.set(value);
  };
  let prevSelected = void 0;
  afterUpdate(() => {
    $$invalidate(23, selected = $selectedValue);
    if (prevSelected !== void 0 && selected !== prevSelected) {
      dispatch("update", $selectedValue);
    }
    prevSelected = selected;
  });
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  function select_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(23, selected = $$new_props.selected);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("inline" in $$new_props)
      $$invalidate(2, inline = $$new_props.inline);
    if ("light" in $$new_props)
      $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("invalid" in $$new_props)
      $$invalidate(7, invalid = $$new_props.invalid);
    if ("invalidText" in $$new_props)
      $$invalidate(8, invalidText = $$new_props.invalidText);
    if ("warn" in $$new_props)
      $$invalidate(9, warn = $$new_props.warn);
    if ("warnText" in $$new_props)
      $$invalidate(10, warnText = $$new_props.warnText);
    if ("helperText" in $$new_props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("noLabel" in $$new_props)
      $$invalidate(12, noLabel = $$new_props.noLabel);
    if ("labelText" in $$new_props)
      $$invalidate(13, labelText = $$new_props.labelText);
    if ("hideLabel" in $$new_props)
      $$invalidate(14, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("required" in $$new_props)
      $$invalidate(15, required = $$new_props.required);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    selected,
    size,
    inline,
    light,
    disabled,
    id,
    name,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    noLabel,
    labelText,
    hideLabel,
    ref,
    required,
    createEventDispatcher,
    setContext,
    afterUpdate,
    writable,
    ChevronDown: ChevronDown_default,
    WarningFilled: WarningFilled_default,
    WarningAltFilled: WarningAltFilled_default,
    dispatch,
    selectedValue,
    defaultSelectId,
    defaultValue,
    itemTypesByValue,
    handleChange,
    prevSelected,
    errorId,
    $defaultValue,
    $selectedValue,
    $itemTypesByValue,
    $defaultSelectId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("selected" in $$props)
      $$invalidate(23, selected = $$new_props.selected);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("inline" in $$props)
      $$invalidate(2, inline = $$new_props.inline);
    if ("light" in $$props)
      $$invalidate(3, light = $$new_props.light);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("invalid" in $$props)
      $$invalidate(7, invalid = $$new_props.invalid);
    if ("invalidText" in $$props)
      $$invalidate(8, invalidText = $$new_props.invalidText);
    if ("warn" in $$props)
      $$invalidate(9, warn = $$new_props.warn);
    if ("warnText" in $$props)
      $$invalidate(10, warnText = $$new_props.warnText);
    if ("helperText" in $$props)
      $$invalidate(11, helperText = $$new_props.helperText);
    if ("noLabel" in $$props)
      $$invalidate(12, noLabel = $$new_props.noLabel);
    if ("labelText" in $$props)
      $$invalidate(13, labelText = $$new_props.labelText);
    if ("hideLabel" in $$props)
      $$invalidate(14, hideLabel = $$new_props.hideLabel);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("required" in $$props)
      $$invalidate(15, required = $$new_props.required);
    if ("prevSelected" in $$props)
      prevSelected = $$new_props.prevSelected;
    if ("errorId" in $$props)
      $$invalidate(16, errorId = $$new_props.errorId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*id*/
    32) {
      $:
        $$invalidate(16, errorId = `error-${id}`);
    }
    if ($$self.$$.dirty[0] & /*selected, $defaultValue*/
    25165824) {
      $:
        selectedValue.set(selected ?? $defaultValue);
    }
  };
  return [
    ref,
    size,
    inline,
    light,
    disabled,
    id,
    name,
    invalid,
    invalidText,
    warn,
    warnText,
    helperText,
    noLabel,
    labelText,
    hideLabel,
    required,
    errorId,
    selectedValue,
    defaultSelectId,
    defaultValue,
    itemTypesByValue,
    handleChange,
    $$restProps,
    selected,
    $defaultValue,
    $$scope,
    slots,
    change_handler_1,
    input_handler_1,
    focus_handler_1,
    blur_handler_1,
    change_handler,
    input_handler,
    focus_handler,
    blur_handler,
    select_binding,
    select_binding_1
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        selected: 23,
        size: 1,
        inline: 2,
        light: 3,
        disabled: 4,
        id: 5,
        name: 6,
        invalid: 7,
        invalidText: 8,
        warn: 9,
        warnText: 10,
        helperText: 11,
        noLabel: 12,
        labelText: 13,
        hideLabel: 14,
        ref: 0,
        required: 15
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment4.name
    });
  }
  get selected() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalidText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalidText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warn() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warn(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get warnText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set warnText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get helperText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set helperText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/carbon-components-svelte/src/Select/SelectItem.svelte
var file5 = "node_modules/carbon-components-svelte/src/Select/SelectItem.svelte";
function create_fragment5(ctx) {
  let option;
  let t_value = (
    /*text*/
    (ctx[1] || /*value*/
    ctx[0]) + ""
  );
  let t;
  let option_class_value;
  let option_style_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { class: true, style: true });
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = /*value*/
      ctx[0];
      set_input_value(option, option.__value);
      option.disabled = /*disabled*/
      ctx[3];
      option.hidden = /*hidden*/
      ctx[2];
      option.selected = /*selected*/
      ctx[4];
      attr_dev(option, "class", option_class_value = /*$$restProps*/
      ctx[5].class);
      attr_dev(option, "style", option_style_value = /*$$restProps*/
      ctx[5].style);
      toggle_class(option, "bx--select-option", true);
      add_location(option, file5, 34, 0, 732);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*text, value*/
      3 && t_value !== (t_value = /*text*/
      (ctx2[1] || /*value*/
      ctx2[0]) + ""))
        set_data_dev(t, t_value);
      if (dirty & /*value*/
      1) {
        prop_dev(
          option,
          "__value",
          /*value*/
          ctx2[0]
        );
        set_input_value(option, option.__value);
      }
      if (dirty & /*disabled*/
      8) {
        prop_dev(
          option,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (dirty & /*hidden*/
      4) {
        prop_dev(
          option,
          "hidden",
          /*hidden*/
          ctx2[2]
        );
      }
      if (dirty & /*selected*/
      16) {
        prop_dev(
          option,
          "selected",
          /*selected*/
          ctx2[4]
        );
      }
      if (dirty & /*$$restProps*/
      32 && option_class_value !== (option_class_value = /*$$restProps*/
      ctx2[5].class)) {
        attr_dev(option, "class", option_class_value);
      }
      if (dirty & /*$$restProps*/
      32 && option_style_value !== (option_style_value = /*$$restProps*/
      ctx2[5].style)) {
        attr_dev(option, "style", option_style_value);
      }
      if (dirty & /*$$restProps*/
      32) {
        toggle_class(option, "bx--select-option", true);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["value", "text", "hidden", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectItem", slots, []);
  let { value = "" } = $$props;
  let { text: text2 = "" } = $$props;
  let { hidden = false } = $$props;
  let { disabled = false } = $$props;
  const id = "ccs-" + Math.random().toString(36);
  const ctx = getContext("Select") || getContext("TimePickerSelect");
  let selected = false;
  const unsubscribe = ctx.selectedValue.subscribe((currentValue) => {
    $$invalidate(4, selected = currentValue === value);
  });
  onMount(() => {
    return () => unsubscribe();
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("text" in $$new_props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("hidden" in $$new_props)
      $$invalidate(2, hidden = $$new_props.hidden);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
  };
  $$self.$capture_state = () => ({
    value,
    text: text2,
    hidden,
    disabled,
    getContext,
    onMount,
    id,
    ctx,
    selected,
    unsubscribe
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("text" in $$props)
      $$invalidate(1, text2 = $$new_props.text);
    if ("hidden" in $$props)
      $$invalidate(2, hidden = $$new_props.hidden);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        (_a = ctx == null ? void 0 : ctx.setDefaultValue) == null ? void 0 : _a.call(ctx, id, value);
    }
  };
  return [value, text2, hidden, disabled, selected, $$restProps];
}
var SelectItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      value: 0,
      text: 1,
      hidden: 2,
      disabled: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectItem",
      options,
      id: create_fragment5.name
    });
  }
  get value() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectItem_default = SelectItem;

// node_modules/carbon-components-svelte/src/LocalStorage/LocalStorage.svelte
function create_fragment6(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function clearAll() {
  localStorage.clear();
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LocalStorage", slots, []);
  let { key = "local-storage-key" } = $$props;
  let { value = "" } = $$props;
  function clearItem() {
    localStorage.removeItem(key);
  }
  const dispatch = createEventDispatcher();
  let prevValue = value;
  function setItem() {
    if (typeof value === "object") {
      localStorage.setItem(key, JSON.stringify(value));
    } else {
      localStorage.setItem(key, value);
    }
  }
  onMount(() => {
    const item = localStorage.getItem(key);
    if (item != null) {
      try {
        $$invalidate(0, value = JSON.parse(item));
      } catch (e) {
        $$invalidate(0, value = item);
      }
    } else {
      setItem(value);
      dispatch("save");
    }
  });
  afterUpdate(() => {
    if (prevValue !== value) {
      setItem(value);
      dispatch("update", { prevValue, value });
    }
    prevValue = value;
  });
  const writable_props = ["key", "value"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<LocalStorage> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    key,
    value,
    clearItem,
    clearAll,
    onMount,
    afterUpdate,
    createEventDispatcher,
    dispatch,
    prevValue,
    setItem
  });
  $$self.$inject_state = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("prevValue" in $$props2)
      prevValue = $$props2.prevValue;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, key, clearItem, clearAll];
}
var LocalStorage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      key: 1,
      value: 0,
      clearItem: 2,
      clearAll: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LocalStorage",
      options,
      id: create_fragment6.name
    });
  }
  get key() {
    throw new Error("<LocalStorage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<LocalStorage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearItem() {
    return this.$$.ctx[2];
  }
  set clearItem(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearAll() {
    return clearAll;
  }
  set clearAll(value) {
    throw new Error("<LocalStorage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LocalStorage_default = LocalStorage;

// node_modules/carbon-components-svelte/src/Theme/Theme.svelte
var { Object: Object_1, console: console_1 } = globals;
var get_default_slot_changes = (dirty) => ({ theme: dirty & /*theme*/
1 });
var get_default_slot_context = (ctx) => ({ theme: (
  /*theme*/
  ctx[0]
) });
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block_22(ctx) {
  let localstorage;
  let updating_value;
  let current;
  function localstorage_value_binding(value) {
    ctx[9](value);
  }
  let localstorage_props = { key: (
    /*persistKey*/
    ctx[2]
  ) };
  if (
    /*theme*/
    ctx[0] !== void 0
  ) {
    localstorage_props.value = /*theme*/
    ctx[0];
  }
  localstorage = new LocalStorage_default({
    props: localstorage_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(localstorage, "value", localstorage_value_binding));
  const block = {
    c: function create() {
      create_component(localstorage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(localstorage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(localstorage, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const localstorage_changes = {};
      if (dirty & /*persistKey*/
      4)
        localstorage_changes.key = /*persistKey*/
        ctx2[2];
      if (!updating_value && dirty & /*theme*/
      1) {
        updating_value = true;
        localstorage_changes.value = /*theme*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      localstorage.$set(localstorage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(localstorage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(localstorage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(localstorage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(98:0) {#if persist}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let select_1;
  let updating_selected;
  let current;
  const select_1_spread_levels = [
    /*select*/
    ctx[5]
  ];
  function select_1_selected_binding(value) {
    ctx[11](value);
  }
  let select_1_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < select_1_spread_levels.length; i += 1) {
    select_1_props = assign(select_1_props, select_1_spread_levels[i]);
  }
  if (
    /*theme*/
    ctx[0] !== void 0
  ) {
    select_1_props.selected = /*theme*/
    ctx[0];
  }
  select_1 = new Select_default({ props: select_1_props, $$inline: true });
  binding_callbacks.push(() => bind(select_1, "selected", select_1_selected_binding));
  const block = {
    c: function create() {
      create_component(select_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(select_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_1_changes = dirty & /*select*/
      32 ? get_spread_update(select_1_spread_levels, [get_spread_object(
        /*select*/
        ctx2[5]
      )]) : {};
      if (dirty & /*$$scope, select*/
      4128) {
        select_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selected && dirty & /*theme*/
      1) {
        updating_selected = true;
        select_1_changes.selected = /*theme*/
        ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      select_1.$set(select_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(select_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(110:30) ",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let toggle_1;
  let current;
  const toggle_1_spread_levels = [
    /*toggle*/
    ctx[4],
    {
      toggled: (
        /*theme*/
        ctx[0] === /*toggle*/
        ctx[4].themes[1]
      )
    }
  ];
  let toggle_1_props = {};
  for (let i = 0; i < toggle_1_spread_levels.length; i += 1) {
    toggle_1_props = assign(toggle_1_props, toggle_1_spread_levels[i]);
  }
  toggle_1 = new Toggle_default({ props: toggle_1_props, $$inline: true });
  toggle_1.$on(
    "toggle",
    /*toggle_handler*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(toggle_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(toggle_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(toggle_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toggle_1_changes = dirty & /*toggle, theme*/
      17 ? get_spread_update(toggle_1_spread_levels, [
        dirty & /*toggle*/
        16 && get_spread_object(
          /*toggle*/
          ctx2[4]
        ),
        {
          toggled: (
            /*theme*/
            ctx2[0] === /*toggle*/
            ctx2[4].themes[1]
          )
        }
      ]) : {};
      toggle_1.$set(toggle_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toggle_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toggle_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toggle_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: '(102:0) {#if render === \\"toggle\\"}',
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      value: (
        /*theme*/
        ctx[0]
      ),
      text: (
        /*themes*/
        ctx[6][
          /*theme*/
          ctx[0]
        ]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(selectitem.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(selectitem.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const selectitem_changes = {};
      if (dirty & /*select*/
      32)
        selectitem_changes.value = /*theme*/
        ctx[0];
      if (dirty & /*select*/
      32)
        selectitem_changes.text = /*themes*/
        ctx[6][
          /*theme*/
          ctx[0]
        ];
      selectitem.$set(selectitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(selectitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(112:4) {#each select.themes as theme (theme)}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*select*/
    ctx[5].themes
  );
  const get_key = (ctx2) => (
    /*theme*/
    ctx2[0]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*select, themes*/
      96) {
        each_value = ensure_array_like_dev(
          /*select*/
          ctx2[5].themes
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(111:2) <Select {...select} bind:selected=\\"{theme}\\">',
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let current;
  let if_block0 = (
    /*persist*/
    ctx[1] && create_if_block_22(ctx)
  );
  const if_block_creators = [create_if_block4, create_if_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*render*/
      ctx2[3] === "toggle"
    )
      return 0;
    if (
      /*render*/
      ctx2[3] === "select"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*persist*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*persist*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, theme*/
        4097)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Theme", slots, ["default"]);
  let { theme = "white" } = $$props;
  let { tokens = {} } = $$props;
  let { persist = false } = $$props;
  let { persistKey = "theme" } = $$props;
  let { render = void 0 } = $$props;
  let { toggle = {
    themes: ["white", "g100"],
    labelA: "",
    labelB: "",
    labelText: "Dark mode",
    hideLabel: false
  } } = $$props;
  const themes = {
    white: "White",
    g10: "Gray 10",
    g80: "Gray 80",
    g90: "Gray 90",
    g100: "Gray 100"
  };
  const themeKeys = Object.keys(themes);
  let { select = {
    themes: themeKeys,
    labelText: "Themes",
    hideLabel: false
  } } = $$props;
  const dispatch = createEventDispatcher();
  const writable_props = ["theme", "tokens", "persist", "persistKey", "render", "toggle", "select"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Theme> was created with unknown prop '${key}'`);
  });
  function localstorage_value_binding(value) {
    theme = value;
    $$invalidate(0, theme);
  }
  const toggle_handler = ({ detail }) => {
    $$invalidate(0, theme = detail.toggled ? toggle.themes[1] : toggle.themes[0]);
  };
  function select_1_selected_binding(value) {
    theme = value;
    $$invalidate(0, theme);
  }
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("tokens" in $$props2)
      $$invalidate(7, tokens = $$props2.tokens);
    if ("persist" in $$props2)
      $$invalidate(1, persist = $$props2.persist);
    if ("persistKey" in $$props2)
      $$invalidate(2, persistKey = $$props2.persistKey);
    if ("render" in $$props2)
      $$invalidate(3, render = $$props2.render);
    if ("toggle" in $$props2)
      $$invalidate(4, toggle = $$props2.toggle);
    if ("select" in $$props2)
      $$invalidate(5, select = $$props2.select);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    theme,
    tokens,
    persist,
    persistKey,
    render,
    toggle,
    themes,
    themeKeys,
    select,
    createEventDispatcher,
    Toggle: Toggle_default,
    Select: Select_default,
    SelectItem: SelectItem_default,
    LocalStorage: LocalStorage_default,
    dispatch
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("tokens" in $$props2)
      $$invalidate(7, tokens = $$props2.tokens);
    if ("persist" in $$props2)
      $$invalidate(1, persist = $$props2.persist);
    if ("persistKey" in $$props2)
      $$invalidate(2, persistKey = $$props2.persistKey);
    if ("render" in $$props2)
      $$invalidate(3, render = $$props2.render);
    if ("toggle" in $$props2)
      $$invalidate(4, toggle = $$props2.toggle);
    if ("select" in $$props2)
      $$invalidate(5, select = $$props2.select);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tokens, theme*/
    129) {
      $:
        if (typeof window !== "undefined") {
          Object.entries(tokens).forEach(([token, value]) => {
            document.documentElement.style.setProperty(`--cds-${token}`, value);
          });
          if (theme in themes) {
            document.documentElement.setAttribute("theme", theme);
            dispatch("update", { theme });
          } else {
            console.warn(`[Theme.svelte] invalid theme "${theme}". Value must be one of: ${JSON.stringify(Object.keys(themes))}`);
          }
        }
    }
  };
  return [
    theme,
    persist,
    persistKey,
    render,
    toggle,
    select,
    themes,
    tokens,
    slots,
    localstorage_value_binding,
    toggle_handler,
    select_1_selected_binding,
    $$scope
  ];
}
var Theme = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      theme: 0,
      tokens: 7,
      persist: 1,
      persistKey: 2,
      render: 3,
      toggle: 4,
      select: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Theme",
      options,
      id: create_fragment7.name
    });
  }
  get theme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tokens() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tokens(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persist() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persist(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistKey() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistKey(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get render() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set render(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Theme_default = Theme;
export {
  Theme_default as default
};
//# sourceMappingURL=carbon-components-svelte_src_Theme_Theme__svelte.js.map
