import "./chunk-6CJGRA3E.js";
import {
  clsx_m_default
} from "./chunk-2TMMHHZA.js";
import {
  writable
} from "./chunk-ANCNHGHB.js";
import {
  SvelteComponentDev,
  action_destroyer,
  dispatch_dev,
  get_store_value,
  init,
  is_function,
  noop,
  run_all,
  safe_not_equal,
  validate_slots
} from "./chunk-54ILQR5V.js";
import "./chunk-NFXY5EW3.js";
import "./chunk-T2T6Q22Z.js";

// node_modules/svelte-body/dist/actions.js
var classList = (node, classString = "") => {
  const classes = writable(clsx_m_default(classString).split(" ").filter(Boolean));
  const unsubscribe = classes.subscribe((list) => {
    if (Array.isArray(list) && (list == null ? void 0 : list.length))
      node.classList.add(...list);
  });
  const unset = () => node.classList.remove(...get_store_value(classes));
  return {
    update: (classString2 = "") => {
      unset();
      classes.set(clsx_m_default(classString2).split(" ").filter(Boolean));
    },
    destroy: () => {
      unset();
      unsubscribe();
    }
  };
};
var style = (node, styleData = {}) => {
  const pseudoElement = document.createElement("div");
  const update = (styleData2 = {}) => {
    if (typeof styleData2 == "string")
      pseudoElement.style.cssText = styleData2;
    if (typeof styleData2 == "object")
      for (const [property, value] of Object.entries(styleData2)) {
        if (property.startsWith("--")) {
          pseudoElement.style.setProperty(property, value);
        } else {
          pseudoElement.style[property] = value;
        }
      }
    node.style.cssText = `
					${node.style.cssText};
					${pseudoElement.style.cssText};
				`;
  };
  update(styleData);
  const unset = () => {
    node.style.cssText = node.style.cssText.replace(pseudoElement.style.cssText, "");
    pseudoElement.style.cssText = "";
  };
  return {
    update: (styleData2) => {
      unset();
      update(styleData2);
    },
    destroy: unset
  };
};

// node_modules/svelte-body/dist/Body.svelte
function create_fragment(ctx) {
  let classList_action;
  let styleAction_action;
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: noop,
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          action_destroyer(classList_action = classList.call(
            null,
            document.body,
            /*classes*/
            ctx[0]
          )),
          action_destroyer(styleAction_action = style.call(
            null,
            document.body,
            /*style*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (classList_action && is_function(classList_action.update) && dirty & /*classes*/
      1)
        classList_action.update.call(
          null,
          /*classes*/
          ctx2[0]
        );
      if (styleAction_action && is_function(styleAction_action.update) && dirty & /*style*/
      2)
        styleAction_action.update.call(
          null,
          /*style*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Body", slots, []);
  let { class: classes = "" } = $$props;
  let { style: style2 = "" } = $$props;
  const writable_props = ["class", "style"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Body> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, classes = $$props2.class);
    if ("style" in $$props2)
      $$invalidate(1, style2 = $$props2.style);
  };
  $$self.$capture_state = () => ({ classList, styleAction: style, classes, style: style2 });
  $$self.$inject_state = ($$props2) => {
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
    if ("style" in $$props2)
      $$invalidate(1, style2 = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [classes, style2];
}
var Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { class: 0, style: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Body",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Body_default = Body;
export {
  Body_default as Body,
  classList,
  style
};
//# sourceMappingURL=svelte-body.js.map
